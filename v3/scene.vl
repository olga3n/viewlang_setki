Scene 
{
	id: thescene
	
	Axis { }
	
	property alias file: inputFile.file
	property alias fileParam: inputFile
	property alias coeffScale: loader.coeff_scale

	// алиас-ы позволяют "вытащить" свойства и объекты "наружу", чтобы ими можно было управлять извне. 
	// заодно дают возможность задать дублирующее имя. это позволяет нам в разных сетка-программах иметь любые имена,
	// а наружу выставлять их как алиас-ы под универсальными однообразными именами. это надо appmix-у, для управления приложениями.

	FileParam 
	{
		id: inputFile
		text: "Grid file:"
    file: thescene.isRoot ? Qt.resolvedUrl( "../ris5.dat" ) : ""
	}
	
	Loader3
	{
		id: loader
		file: inputFile.file
	}

	Text 
	{
		text: "Zones: " + (loader.grid ? loader.grid.length : 0)
		property var tag: "left"
	}

	Text 
	{
		text: "Approximation"
		property var tag: "right"
	}

	Param 
	{
		text: "\ndk[%]"
		id: dk
		value: 0.2
		min: 0.1
		max: 1
		step: 0.1
		property var tag: "right"
		enableSliding: false
	}

	Param 
	{
		text: "dj[%]"
		id: dj
		value: 0.2
		min: 0.1
		max: 1
		step: 0.1
		property var tag: "right"
		enableSliding: false // выключаем enableSliding - параметр будет меняться только когда пользователь отпустил мышку.
	}

	Param 
	{
		text: "di[%]"
		id: di
		value: 0.2
		min: 0.1
		max: 1
		step: 0.1
		property var tag: "right"
		enableSliding: false
		// Component.onCompleted: makeLater(this); почему убрано - это надо вызывать только для элементов, которые создаются репитером
	}

	Param 
	{
		text: "dp[%]"
		id: dp
		value: 1
		min: 0.1
		max: 1
		step: 0.1
		property var tag: "right"
		enableSliding: false
	}	

	Column
	{
		CheckBox 
		{
			id: check_R
			property var tag: "right"
			spacing: 5
			width: 100
			text: "R"
			checked: true
		}
		CheckBox 
		{
			id: check_G
			property var tag: "right"
			spacing: 5
			width: 100
			text: "G"
			checked: true
		}
		CheckBox 
		{
			id: check_B
			property var tag: "right"
			spacing: 5
			width: 100
			text: "B"
			checked: true
		}
	}

	Column
	{
		property var tag: "left"

		Repeater
		{
			model: loader.grid ? loader.grid.length : 0

			Column
			{
				property var tag: "left"
				
				CheckBox 
				{
					id: check_zone
					property var tag: "left"
					spacing: 5
					width: 100
					text: "zone #" + index
					checked: true
				}

				Item
				{
					id: grid
					property var z: index
					
					Repeater
					{
						model: 2 + Math.floor( dk.value * loader.grid[ grid.z ].length )

						Item
						{
							property var k: Math.round( index / dk.value )
							property var q: upd_k();

							function upd_k()
							{
								if ( k >= loader.grid[ grid.z ].length ) 
									k = loader.grid[ grid.z ].length - 1 
							}

							// blue part --------------------------------------------

							Repeater
							{
								model: 2 + Math.floor( dj.value * 
									loader.grid[ grid.z ][ k ].length )

								Item
								{	
									property var j: Math.round( index / dj.value )
									property var q: upd_j();

									function upd_j()
									{
										if ( j >= loader.grid[ grid.z ][ k ].length ) 
											j = loader.grid[ grid.z ][ k ].length - 1 
									}

									Lines 
									{
										linestrip: true
										radius: 1
										positions: grid.line( k, j, -1 )
										visible: check_zone.checked && check_B.checked && 
											grid.visible( k, j, -1 )
										
										color: ( 
												j == 0 || 
												k == 0 ||
												j == loader.grid[ grid.z ][ k ].length - 1 ||
												k == loader.grid[ grid.z ].length - 1
											)? 0x0000cc : 0x0099cc

										Component.onCompleted: makeLater(this);
									}
								}
							}

							// red part ------------------------------------------

							Repeater
							{
								model: 2 + Math.floor( di.value * 
									loader.grid[ grid.z ][ k ][ 0 ].length )

								Item
								{
									property var i: Math.round( index / di.value )
									property var q: upd_i();

									function upd_i()
									{
										if ( i >= loader.grid[ grid.z ][ k ][ 0 ].length ) 
											i = loader.grid[ grid.z ][ k ][ 0 ].length - 1 
									}

									Lines 
									{
										linestrip: true
										radius: 1
										positions: grid.line( k, -1, i )
										visible: check_zone.checked && check_R.checked && 
											grid.visible( k, -1, i )
										
										color: ( 
												i == 0 || 
												k == 0 ||
												i == loader.grid[ grid.z ][ k ][ 0 ].length - 1 ||
												k == loader.grid[ grid.z ].length - 1
											)? 0xcc0000 : 0xcc0099

										Component.onCompleted: makeLater(this);
									}
								}
							}
						}
					}

					// green part -------------------------------------------

					Repeater
					{
						model: 2 + Math.floor( dj.value * 
							loader.grid[ grid.z ][ 0 ].length )

						Item
						{
							property var j: index * Math.round( 1 / dj.value )
							property var q: upd_j();

							function upd_j()
							{
								if ( j >= loader.grid[ grid.z ][ 0 ].length ) 
									j = loader.grid[ grid.z ][ 0 ].length - 1 
							}

							Repeater
							{
								model: 2 + Math.floor( di.value * 
									loader.grid[ grid.z ][ 0 ][ j ].length )

								Item
								{
									property var i: index * Math.round( 1 / di.value )
									property var q: upd_i();

									function upd_i()
									{
										if ( i >= loader.grid[ grid.z ][ 0 ][ j ].length ) 
											i = loader.grid[ grid.z ][ 0 ][ j ].length - 1 
									}

									Lines 
									{
										linestrip: true
										radius: 1
										positions: grid.line( -1, j, i )
										visible: check_zone.checked && check_G.checked && 
											grid.visible( -1, j, i )
										
										color: ( 
												i == 0 || 
												j == 0 ||
												i == loader.grid[ grid.z ][ 0 ][ j ].length - 1 ||
												j == loader.grid[ grid.z ][ 0 ].length - 1
											)? 0x00cc00 : 0x99ff55

										Component.onCompleted: makeLater(this);
									}
								}
							}
						}
					}

					function line(k, j, i)
					{
						zone = loader.grid[ index ];

						pnts = [];

						step = Math.floor(1 / dp.value);

						if( i == -1 )
						{
							pnts.push(zone[k][j][0][0], zone[k][j][0][1], zone[k][j][0][2]);

							for (ii = 1; ii < zone[k][j].length; ii += step)
								pnts.push(zone[k][j][ii][0], zone[k][j][ii][1], zone[k][j][ii][2]);

							pnts.push(
								zone[k][j][zone[k][j].length - 1][0], 
								zone[k][j][zone[k][j].length - 1][1], 
								zone[k][j][zone[k][j].length - 1][2])
						}
						else if ( j == -1 )
						{
							pnts.push(zone[k][0][i][0], zone[k][0][i][1], zone[k][0][i][2]);

							for (ji = 1; ji < zone[k].length; ji += step )
								pnts.push(zone[k][ji][i][0], zone[k][ji][i][1], zone[k][ji][i][2]);

							pnts.push(
								zone[k][zone[k].length - 1][i][0], 
								zone[k][zone[k].length - 1][i][1], 
								zone[k][zone[k].length - 1][i][2]);
						}
						else if ( k == -1 )
						{
							pnts.push(zone[0][j][i][0], zone[0][j][i][1], zone[0][j][i][2]);

							for (ki = 1; ki < zone.length; ki += step )
								pnts.push(zone[ki][j][i][0], zone[ki][j][i][1], zone[ki][j][i][2]);

							pnts.push(
								zone[zone.length - 1][j][i][0], 
								zone[zone.length - 1][j][i][1], 
								zone[zone.length - 1][j][i][2]);
						}

						return pnts;
					}

					function visible(k, j, i)
					{
						zone = loader.grid[ index ];

						return (
							( check_ext.checked &&
								(
									( i == -1 && (
										j == 0 || 
										k == 0 ||
										j == zone[ k ].length - 1 ||
										k == zone.length - 1)
									) || ( j == -1 && (
										i == 0 ||
										k == 0 ||
										i == zone[ k ][ 0 ].length - 1 ||
										k == zone.length - 1)
									) || ( k == -1 && (
										i == 0 ||
										j == 0 ||
										i == zone[ 0 ][ j ].length - 1 ||
										j == zone[ 0 ].length - 1)
									)
								)
							) || (check_int.checked &&
								i != 0 && j != 0 && k != 0 &&
								i != zone[ (k == -1)? 0: k ][ (j == -1)? 0: j ].length - 1 &&
								j != zone[ (k == -1)? 0: k ].length - 1 &&
								k != zone.length - 1
							)
						)? true: false;
					}
				}
			}
		}
	}

	Text 
	{
		text: "\nInt/Ext"
		property var tag: "left"
	}

	Column
	{
		CheckBox 
		{
			id: check_ext
			property var tag: "left"
			spacing: 5
			width: 100
			text: "ext"
			checked: true
			Component.onCompleted: makeLater(this);
		}
		CheckBox 
		{
			id: check_int
			property var tag: "left"
			spacing: 5
			width: 100
			text: "int"
			checked: true
			Component.onCompleted: makeLater(this);
		}
	}
}
