// Generated by CoffeeScript 1.9.3
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.gen_lines = function(data, scale_coeff, detail, modes) {
    var border_bold, calc_color, color_border, fn, fn1, i_limit, i_size, j, j_limit, j_size, k, k_limit, k_size, l, line_dashed, m, n, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, results;
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    k_limit = Math.ceil(data.length / detail[0]) * detail[0];
    j_limit = Math.ceil(data[0].length / detail[1]) * detail[1];
    i_limit = Math.ceil(data[0][0].length / detail[2]) * detail[2];
    if (modes.length < 4) {
      calc_color = function(dir, k, j, i) {
        var i_coeff, j_coeff, k_coeff;
        i_coeff = dir === 1 ? 0x88 : (i - k_first) / i_size * 0xff;
        j_coeff = dir === 2 ? 0x88 : (j - k_first) / j_size * 0xff;
        k_coeff = dir === 3 ? 0x88 : (k - k_first) / k_size * 0xff;
        return (k_coeff << 16) + (j_coeff << 8) + i_coeff;
      };
    } else if (modes[3].length > 2) {
      calc_color = function(dir, k, j, i) {
        return modes[3][dir];
      };
    }
    if (modes.length > 3 && modes[3].length > 0) {
      line_dashed = modes[3][0];
    } else {
      line_dashed = false;
    }
    if (modes.length > 4 && modes[4].length > 1) {
      color_border = modes[4][1];
      border_bold = modes[4][0];
    } else {
      color_border = '#000000';
      border_bold = true;
    }
    if (modes[0]) {
      fn = function(k) {
        var j, m, ref3, ref4, ref5, results;
        if (k > k_last) {
          k = k_last;
        }
        results = [];
        for (j = m = ref3 = j_first, ref4 = j_limit, ref5 = detail[1]; ref5 > 0 ? m <= ref4 : m >= ref4; j = m += ref5) {
          results.push((function(j) {
            var color, dashed, fn1, i, n, pnts, ref6, ref7, width;
            if (j > j_last) {
              j = j_last;
            }
            pnts = [];
            fn1 = function(i) {
              return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
            };
            for (i = n = ref6 = i_first, ref7 = i_last; ref6 <= ref7 ? n <= ref7 : n >= ref7; i = ref6 <= ref7 ? ++n : --n) {
              fn1(i);
            }
            if (border_bold && (k === k_first || k === k_last) && (j === j_first || j === j_last)) {
              width = 2.5;
            } else {
              width = 1;
            }
            if ((k === k_first || k === k_last) || (j === j_first || j === j_last)) {
              color = color_border;
              dashed = false;
            } else {
              color = calc_color(1, k, j, 0);
              dashed = line_dashed;
            }
            return add_line(pnts, scale_coeff, color, dashed, width);
          })(j));
        }
        return results;
      };
      for (k = l = ref = k_first, ref1 = k_limit, ref2 = detail[0]; ref2 > 0 ? l <= ref1 : l >= ref1; k = l += ref2) {
        fn(k);
      }
    }
    if (modes[1]) {
      fn1 = function(k) {
        var i, n, ref6, ref7, ref8, results;
        if (k > k_last) {
          k = k_last;
        }
        results = [];
        for (i = n = ref6 = i_first, ref7 = i_limit, ref8 = detail[2]; ref8 > 0 ? n <= ref7 : n >= ref7; i = n += ref8) {
          results.push((function(i) {
            var color, dashed, fn2, j, o, pnts, ref10, ref9, width;
            if (i > i_last) {
              i = i_last;
            }
            pnts = [];
            fn2 = function(j) {
              return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
            };
            for (j = o = ref9 = j_first, ref10 = j_last; ref9 <= ref10 ? o <= ref10 : o >= ref10; j = ref9 <= ref10 ? ++o : --o) {
              fn2(j);
            }
            if (border_bold && (k === k_first || k === k_last) && (i === i_first || i === i_last)) {
              width = 2.5;
            } else {
              width = 1;
            }
            if ((k === k_first || k === k_last) || (i === i_first || i === i_last)) {
              color = color_border;
              dashed = false;
            } else {
              color = calc_color(2, k, 0, i);
              dashed = line_dashed;
            }
            return add_line(pnts, scale_coeff, color, dashed, width);
          })(i));
        }
        return results;
      };
      for (k = m = ref3 = k_first, ref4 = k_limit, ref5 = detail[0]; ref5 > 0 ? m <= ref4 : m >= ref4; k = m += ref5) {
        fn1(k);
      }
    }
    if (modes[2]) {
      results = [];
      for (j = n = ref6 = j_first, ref7 = j_limit, ref8 = detail[1]; ref8 > 0 ? n <= ref7 : n >= ref7; j = n += ref8) {
        results.push((function(j) {
          var i, o, ref10, ref11, ref9, results1;
          if (j > j_last) {
            j = j_last;
          }
          results1 = [];
          for (i = o = ref9 = i_first, ref10 = i_limit, ref11 = detail[2]; ref11 > 0 ? o <= ref10 : o >= ref10; i = o += ref11) {
            results1.push((function(i) {
              var color, dashed, fn2, p, pnts, ref12, ref13, width;
              if (i > i_last) {
                i = i_last;
              }
              pnts = [];
              fn2 = function(k) {
                return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
              };
              for (k = p = ref12 = k_first, ref13 = k_last; ref12 <= ref13 ? p <= ref13 : p >= ref13; k = ref12 <= ref13 ? ++p : --p) {
                fn2(k);
              }
              if (border_bold && (j === j_first || j === j_last) && (i === i_first || i === i_last)) {
                width = 2.5;
              } else {
                width = 1;
              }
              if ((j === j_first || j === j_last) || (i === i_first || i === i_last)) {
                color = color_border;
                dashed = false;
              } else {
                color = calc_color(3, 0, j, i);
                dashed = line_dashed;
              }
              return add_line(pnts, scale_coeff, color, dashed, width);
            })(i));
          }
          return results1;
        })(j));
      }
      return results;
    }
  };

  root.gen_surfaces = function(data, scale_coeff, detail, modes) {
    var calc_color, color, fn, fn1, fn2, i, i_limit, i_lst_back, i_lst_front, i_size, j, j_limit, j_lst_back, j_lst_front, j_size, k, k_index, k_limit, k_lst_back, k_lst_front, k_size, l, len, m, n, o, opacity, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, results;
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    k_limit = Math.ceil(data.length / detail[0]) * detail[0];
    j_limit = Math.ceil(data[0].length / detail[1]) * detail[1];
    i_limit = Math.ceil(data[0][0].length / detail[2]) * detail[2];
    calc_color = function(k, j, i) {
      var i_coeff, j_coeff, k_coeff;
      k_coeff = (k - k_first) / k_size;
      j_coeff = (j - j_first) / j_size;
      i_coeff = (i - i_first) / i_size;
      return ((0xff * k_coeff) << 16) + ((0xff * j_coeff) << 8) + (0xff * i_coeff);
    };
    k_lst_front = [];
    k_lst_back = [];
    fn = function(k) {
      if (k > k_last) {
        k = k_last;
      }
      k_lst_front.push(k);
      return k_lst_back.push(k);
    };
    for (k = l = ref = k_first, ref1 = k_limit, ref2 = detail[0]; ref2 > 0 ? l <= ref1 : l >= ref1; k = l += ref2) {
      fn(k);
    }
    k_lst_back.reverse();
    j_lst_front = [];
    j_lst_back = [];
    fn1 = function(j) {
      if (j > j_last) {
        j = j_last;
      }
      j_lst_front.push(j);
      return j_lst_back.push(j);
    };
    for (j = m = ref3 = j_first, ref4 = j_limit, ref5 = detail[1]; ref5 > 0 ? m <= ref4 : m >= ref4; j = m += ref5) {
      fn1(j);
    }
    j_lst_back.reverse();
    i_lst_front = [];
    i_lst_back = [];
    fn2 = function(i) {
      if (i > i_last) {
        i = i_last;
      }
      i_lst_front.push(i);
      return i_lst_back.push(i);
    };
    for (i = n = ref6 = i_first, ref7 = i_limit, ref8 = detail[2]; ref8 > 0 ? n <= ref7 : n >= ref7; i = n += ref8) {
      fn2(i);
    }
    i_lst_back.reverse();
    if (modes.length > 3 && modes[3].length > 0) {
      opacity = modes[3][0];
    } else {
      opacity = 0.5;
    }
    if (modes.length > 3 && modes[3].length > 3) {
      color = [modes[3][1], modes[3][2], modes[3][3]];
    } else {
      color = ['#00ffff', '#ff00ff', '#ffff00'];
    }
    results = [];
    for (k_index = o = 0, len = k_lst_back.length; o < len; k_index = ++o) {
      k = k_lst_back[k_index];
      results.push((function(k) {
        var faces, fn3, fn4, fn5, fn6, fn7, fn8, j_index, len1, len2, p, q, r, ref10, ref11, ref12, ref13, ref14, ref9, s, t, u, vertices;
        vertices = [];
        fn3 = function(j) {
          var q, ref11, ref12, results1;
          results1 = [];
          for (i = q = ref11 = i_first, ref12 = i_last; ref11 <= ref12 ? q <= ref12 : q >= ref12; i = ref11 <= ref12 ? ++q : --q) {
            results1.push((function(i) {
              return vertices.push(new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]));
            })(i));
          }
          return results1;
        };
        for (j = p = ref9 = j_first, ref10 = j_last; ref9 <= ref10 ? p <= ref10 : p >= ref10; j = ref9 <= ref10 ? ++p : --p) {
          fn3(j);
        }
        faces = [];
        fn4 = function(j) {
          var r, ref12, results1;
          results1 = [];
          for (i = r = 0, ref12 = i_size - 1; 0 <= ref12 ? r <= ref12 : r >= ref12; i = 0 <= ref12 ? ++r : --r) {
            results1.push((function(i) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = new THREE.Face3(b, a + 1, a);
              face_1 = new THREE.Face3(b + 1, a + 1, b);
              return faces.push(face_0, face_1);
            })(i));
          }
          return results1;
        };
        for (j = q = 0, ref11 = j_size - 1; 0 <= ref11 ? q <= ref11 : q >= ref11; j = 0 <= ref11 ? ++q : --q) {
          fn4(j);
        }
        if (modes[0]) {
          add_surface(vertices, scale_coeff, faces, color[0], opacity);
        }
        if (k_index < k_lst_back.length - 1) {
          fn5 = function(j) {
            var fn6, fn7, i_index, len2, len3, ref12, ref13, results1, s, t, u;
            vertices = [];
            ref12 = [k_lst_back[k_index], k_lst_back[k_index + 1]];
            fn6 = function(k) {
              var ref13, ref14, results1, t;
              results1 = [];
              for (i = t = ref13 = i_first, ref14 = i_last; ref13 <= ref14 ? t <= ref14 : t >= ref14; i = ref13 <= ref14 ? ++t : --t) {
                results1.push((function(i) {
                  return vertices.push(new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]));
                })(i));
              }
              return results1;
            };
            for (s = 0, len2 = ref12.length; s < len2; s++) {
              k = ref12[s];
              fn6(k);
            }
            faces = [];
            fn7 = function(i, k) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * k + i;
              b = (i_size + 1) * (k + 1) + i;
              face_0 = new THREE.Face3(b, a + 1, a);
              face_1 = new THREE.Face3(b + 1, a + 1, b);
              return faces.push(face_0, face_1);
            };
            for (i = t = 0, ref13 = i_size - 1; 0 <= ref13 ? t <= ref13 : t >= ref13; i = 0 <= ref13 ? ++t : --t) {
              fn7(i, 0);
            }
            if (modes[1]) {
              add_surface(vertices, scale_coeff, faces, color[1], opacity);
            }
            if (j_index < j_lst_back.length - 1) {
              results1 = [];
              for (i_index = u = 0, len3 = i_lst_back.length; u < len3; i_index = ++u) {
                i = i_lst_back[i_index];
                results1.push((function(i) {
                  var face_0, face_1, fn8, len4, ref14, v;
                  vertices = [];
                  ref14 = [k_lst_back[k_index], k_lst_back[k_index + 1]];
                  fn8 = function(k) {
                    var len5, ref15, results2, w;
                    ref15 = [j_lst_back[j_index], j_lst_back[j_index + 1]];
                    results2 = [];
                    for (w = 0, len5 = ref15.length; w < len5; w++) {
                      j = ref15[w];
                      results2.push((function(j) {
                        return vertices.push(new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]));
                      })(j));
                    }
                    return results2;
                  };
                  for (v = 0, len4 = ref14.length; v < len4; v++) {
                    k = ref14[v];
                    fn8(k);
                  }
                  face_0 = new THREE.Face3(2, 1, 0);
                  face_1 = new THREE.Face3(3, 1, 2);
                  faces = [face_0, face_1];
                  if (modes[2]) {
                    return add_surface(vertices, scale_coeff, faces, color[2], opacity);
                  }
                })(i));
              }
              return results1;
            }
          };
          for (j_index = r = 0, len1 = j_lst_back.length; r < len1; j_index = ++r) {
            j = j_lst_back[j_index];
            fn5(j);
          }
        }
        k = k_lst_front[k_index];
        if (k_index < k_lst_front.length - 1) {
          fn6 = function(j) {
            var fn7, fn8, fn9, i_index, len3, len4, ref12, ref13, t, u, v;
            if (j_index < j_lst_front.length - 1) {
              fn7 = function(i) {
                var face_0, face_1, fn8, len4, ref12, u;
                vertices = [];
                ref12 = [k_lst_front[k_index], k_lst_front[k_index + 1]];
                fn8 = function(k) {
                  var len5, ref13, results1, v;
                  ref13 = [j_lst_front[j_index], j_lst_front[j_index + 1]];
                  results1 = [];
                  for (v = 0, len5 = ref13.length; v < len5; v++) {
                    j = ref13[v];
                    results1.push((function(j) {
                      return vertices.push(new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]));
                    })(j));
                  }
                  return results1;
                };
                for (u = 0, len4 = ref12.length; u < len4; u++) {
                  k = ref12[u];
                  fn8(k);
                }
                face_0 = new THREE.Face3(0, 1, 2);
                face_1 = new THREE.Face3(2, 1, 3);
                faces = [face_0, face_1];
                if (modes[2]) {
                  return add_surface(vertices, scale_coeff, faces, color[2], opacity);
                }
              };
              for (i_index = t = 0, len3 = i_lst_front.length; t < len3; i_index = ++t) {
                i = i_lst_front[i_index];
                fn7(i);
              }
            }
            vertices = [];
            ref12 = [k_lst_back[k_index], k_lst_back[k_index + 1]];
            fn8 = function(k) {
              var ref13, ref14, results1, v;
              results1 = [];
              for (i = v = ref13 = i_first, ref14 = i_last; ref13 <= ref14 ? v <= ref14 : v >= ref14; i = ref13 <= ref14 ? ++v : --v) {
                results1.push((function(i) {
                  return vertices.push(new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]));
                })(i));
              }
              return results1;
            };
            for (u = 0, len4 = ref12.length; u < len4; u++) {
              k = ref12[u];
              fn8(k);
            }
            faces = [];
            fn9 = function(i, k) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * k + i;
              b = (i_size + 1) * (k + 1) + i;
              face_0 = new THREE.Face3(a, a + 1, b);
              face_1 = new THREE.Face3(b, a + 1, b + 1);
              return faces.push(face_0, face_1);
            };
            for (i = v = 0, ref13 = i_size - 1; 0 <= ref13 ? v <= ref13 : v >= ref13; i = 0 <= ref13 ? ++v : --v) {
              fn9(i, 0);
            }
            if (modes[1]) {
              return add_surface(vertices, scale_coeff, faces, color[1], opacity);
            }
          };
          for (j_index = s = 0, len2 = j_lst_front.length; s < len2; j_index = ++s) {
            j = j_lst_front[j_index];
            fn6(j);
          }
        }
        k = k_lst_front[k_index];
        vertices = [];
        fn7 = function(j) {
          var ref14, ref15, results1, u;
          results1 = [];
          for (i = u = ref14 = i_first, ref15 = i_last; ref14 <= ref15 ? u <= ref15 : u >= ref15; i = ref14 <= ref15 ? ++u : --u) {
            results1.push((function(i) {
              return vertices.push(new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]));
            })(i));
          }
          return results1;
        };
        for (j = t = ref12 = j_first, ref13 = j_last; ref12 <= ref13 ? t <= ref13 : t >= ref13; j = ref12 <= ref13 ? ++t : --t) {
          fn7(j);
        }
        faces = [];
        fn8 = function(j) {
          var ref15, results1, v;
          results1 = [];
          for (i = v = 0, ref15 = i_size - 1; 0 <= ref15 ? v <= ref15 : v >= ref15; i = 0 <= ref15 ? ++v : --v) {
            results1.push((function(i) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = new THREE.Face3(a, a + 1, b);
              face_1 = new THREE.Face3(b, a + 1, b + 1);
              return faces.push(face_0, face_1);
            })(i));
          }
          return results1;
        };
        for (j = u = 0, ref14 = j_size - 1; 0 <= ref14 ? u <= ref14 : u >= ref14; j = 0 <= ref14 ? ++u : --u) {
          fn8(j);
        }
        if (modes[0]) {
          return add_surface(vertices, scale_coeff, faces, color[0], opacity);
        }
      })(k));
    }
    return results;
  };

  root.gen_spheres = function(data, scale_coeff, detail, range, options, mode) {
    var calc_color, k, l, len, ref, results;
    calc_color = function(k, j, i) {
      return ((k === k_first ? 0x00 : 0xff) << 16) + ((j === j_first ? 0x00 : 0xff) << 8) + (i === i_first ? 0x00 : 0xff);
    };
    ref = [k_first, k_last];
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      k = ref[l];
      results.push((function(k) {
        var j, len1, m, ref1, results1;
        ref1 = [j_first, j_last];
        results1 = [];
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          j = ref1[m];
          results1.push((function(j) {
            var i, len2, n, ref2, results2;
            ref2 = [i_first, i_last];
            results2 = [];
            for (n = 0, len2 = ref2.length; n < len2; n++) {
              i = ref2[n];
              results2.push((function(i) {
                var color, position;
                position = data[k][j][i].slice(0, 3);
                color = calc_color(k, j, i);
                return add_sphere(position, scale_coeff, color, 0.1);
              })(i));
            }
            return results2;
          })(j));
        }
        return results1;
      })(k));
    }
    return results;
  };

  root.add_line = function(pnts, scale_coeff, color, dashed, width) {
    var geometry, material, sceneObject;
    if (width == null) {
      width = 1;
    }
    geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(pnts), 3));
    geometry.computeBoundingSphere();
    if (dashed) {
      material = new THREE.LineDashedMaterial({
        color: color,
        linewidth: width,
        dashSize: 0.02,
        gapSize: 0.01
      });
      geometry.computeLineDistances();
    } else {
      material = new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      });
    }
    sceneObject = new THREE.Line(geometry, material);
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return obj.add(sceneObject);
  };

  root.add_surface = function(vertices, scale_coeff, faces, color, opacity) {
    var geometry, material, sceneObject;
    geometry = new THREE.Geometry();
    material = new THREE.MeshBasicMaterial({
      color: color,
      side: THREE.FrontSide,
      transparent: true,
      opacity: opacity
    });
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return obj.add(sceneObject);
  };

  root.add_sphere = function(position, scale_coeff, color, size) {
    var geometry, material, sceneObject;
    geometry = new THREE.SphereBufferGeometry(size);
    material = new THREE.MeshBasicMaterial({
      color: color
    });
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.position.x = position[0] * scale_coeff;
    sceneObject.position.y = position[1] * scale_coeff;
    sceneObject.position.z = position[2] * scale_coeff;
    return obj.add(sceneObject);
  };

  root.Smth = {
    init: function(data, scale_coeff, detail, modes, range, range_modes) {
      var ref;
      root.obj = new THREE.Object3D();
      if (modes.length === 0) {
        modes = [[true, true, true], [false, false, false], [true]];
      }
      ref = [0, 0, 0], root.k_first = ref[0], root.j_first = ref[1], root.i_first = ref[2];
      root.k_last = data.length - 1;
      root.j_last = data[0].length - 1;
      root.i_last = data[0][0].length - 1;
      if (modes[2][0]) {
        gen_spheres(data, scale_coeff);
      }
      gen_surfaces(data, scale_coeff, detail, modes[1]);
      gen_lines(data, scale_coeff, detail, modes[0]);
      console.log("Detail: ", detail);
      console.log("Objects:", root.obj.children.length);
      console.log("ok :D");
      return root.obj;
    }
  };

  console.log("Smth init");

}).call(this);
