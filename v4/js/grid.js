// Generated by CoffeeScript 1.10.0
(function() {
  var root,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.gen_lines = function(data, scale_coeff, detail, directions, materials, borders, filtered, filter_detail, filter_directions, filter_materials) {
    var add_seg, border_color, border_line, border_material, border_points, calc_material, coeff, filter_border_color, filter_border_line, filter_border_material, filter_borders, filter_last_border_line, fn, fn1, i_first, i_size, j, j_first, j_size, k, k_first, k_size, last_border_line, last_border_material, n, o, q, ref, ref1, ref2, ref3, ref4, results;
    if (directions.length < 4) {
      directions = [true, true, true, true];
    }
    if (filter_directions.length < 4) {
      filter_directions = [true, true, true, true];
    }
    coeff = 0;
    border_color = "#000000";
    border_material = [
      new THREE.LineBasicMaterial({
        color: border_color,
        linewidth: 1
      }), coeff + 3
    ];
    filter_borders = [[filter_detail[0][0], filter_detail[0][filter_detail[0].length - 1]], [filter_detail[1][0], filter_detail[1][filter_detail[1].length - 1]], [filter_detail[2][0], filter_detail[2][filter_detail[2].length - 1]]];
    coeff = 5;
    filter_border_color = "#0000ff";
    filter_border_material = [
      new THREE.LineBasicMaterial({
        color: filter_border_color,
        linewidth: 1
      }), coeff + 3
    ];
    last_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    if (borders.length > 5) {
      filter_last_border_line = function(dir, k, j, i) {
        var r;
        if (dir === 0) {
          r = indexOf.call(borders[3], k) >= 0 && indexOf.call(borders[4], j) >= 0 ? true : false;
        } else if (dir === 1) {
          r = indexOf.call(borders[3], k) >= 0 && indexOf.call(borders[5], i) >= 0 ? true : false;
        } else if (dir === 2) {
          r = indexOf.call(borders[4], j) >= 0 && indexOf.call(borders[5], i) >= 0 ? true : false;
        }
        return r;
      };
    } else {
      filter_last_border_line = function(dir, k, j, i) {
        return false;
      };
    }
    filter_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(filter_borders[0], k) >= 0 || indexOf.call(filter_borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(filter_borders[0], k) >= 0 || indexOf.call(filter_borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(filter_borders[1], j) >= 0 || indexOf.call(filter_borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    ref = [0, 0, 0], k_first = ref[0], j_first = ref[1], i_first = ref[2];
    ref1 = [k_last, j_last, i_last], k_size = ref1[0], j_size = ref1[1], i_size = ref1[2];
    calc_material = function(dir, k, j, i, filter) {
      var color, i_coeff, j_coeff, k_coeff, m, mid;
      if (filter == null) {
        filter = false;
      }
      if (filter === true) {
        coeff = 5;
        if (filter_materials.length < 4) {
          if (filter_border_line(dir, k, j, i)) {
            m = filter_border_material;
          } else {
            mid = 0xff;
            i_coeff = dir === 0 ? mid : (i - i_first) / i_size * 0xff;
            j_coeff = dir === 1 ? mid : (j - j_first) / j_size * 0xff;
            k_coeff = dir === 2 ? mid : (k - k_first) / k_size * 0xff;
            color = (i_coeff << 16) + (k_coeff << 8) + j_coeff;
            m = [
              new THREE.LineBasicMaterial({
                color: color,
                linewidth: 1
              }), dir + coeff
            ];
          }
        } else {
          if (filter_border_line(dir, k, j, i)) {
            m = [filter_materials[3], coeff + 3];
          } else {
            m = filter_directions[3] ? [filter_materials[dir], dir + coeff] : [];
          }
        }
      } else {
        coeff = 0;
        if (materials.length < 4) {
          if (border_line(dir, k, j, i)) {
            m = border_material;
          } else {
            mid = 0x55;
            i_coeff = dir === 0 ? mid : (i - i_first) / i_size * 0xff;
            j_coeff = dir === 1 ? mid : (j - j_first) / j_size * 0xff;
            k_coeff = dir === 2 ? mid : (k - k_first) / k_size * 0xff;
            color = (i_coeff << 16) + (k_coeff << 8) + j_coeff;
            m = [
              new THREE.LineBasicMaterial({
                color: color,
                linewidth: 1
              }), dir + coeff
            ];
          }
        } else {
          if (last_border_line(dir, k, j, i)) {
            m = [materials[4], coeff + 4];
          } else if (border_line(dir, k, j, i)) {
            m = [materials[3], coeff + 3];
          } else {
            m = directions[3] ? [materials[dir], dir + coeff] : [];
          }
        }
      }
      return m;
    };
    last_border_material = new THREE.MeshBasicMaterial({
      color: 0x000000,
      side: THREE.DoubleSide
    });
    border_points = function(dir, a, b, x_seg, pnts, faces) {
      var len, n, results, x, x_ind;
      results = [];
      for (x_ind = n = 0, len = x_seg.length; n < len; x_ind = ++n) {
        x = x_seg[x_ind];
        results.push((function(x) {
          var i, j, k, ref2, ref3, ref4, s;
          if (dir === 0) {
            ref2 = [a, b, x], k = ref2[0], j = ref2[1], i = ref2[2];
          } else if (dir === 1) {
            ref3 = [a, x, b], k = ref3[0], j = ref3[1], i = ref3[2];
          } else if (dir === 2) {
            ref4 = [x, a, b], k = ref4[0], j = ref4[1], i = ref4[2];
          }
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff + 0.05, data[k][j][i][1] * scale_coeff, data[k][j][i][2] * scale_coeff));
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff, data[k][j][i][1] * scale_coeff + 0.05, data[k][j][i][2] * scale_coeff));
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff, data[k][j][i][1] * scale_coeff, data[k][j][i][2] * scale_coeff + 0.05));
          if (x_ind !== 0) {
            s = (x_ind - 1) * 3;
            faces.push(new THREE.Face3(s, s + 1, s + 3));
            faces.push(new THREE.Face3(s + 1, s + 2, s + 4));
            faces.push(new THREE.Face3(s + 2, s, s + 5));
            faces.push(new THREE.Face3(s + 1, s + 4, s + 3));
            faces.push(new THREE.Face3(s + 2, s + 5, s + 4));
            return faces.push(new THREE.Face3(s, s + 3, s + 5));
          }
        })(x));
      }
      return results;
    };
    add_seg = function(p, dir, k, j, i, filter) {
      var m;
      if (filter == null) {
        filter = false;
      }
      if (filter === true) {
        if (filter_directions[dir] && p.length > 1) {
          m = calc_material(dir, k, j, i, true);
          if (m.length > 1) {
            return add_line(p, scale_coeff, m[0], m[1]);
          }
        }
      } else {
        if (directions[dir] && p.length > 1) {
          m = calc_material(dir, k, j, i);
          if (m.length > 1) {
            return add_line(p, scale_coeff, m[0], m[1]);
          }
        }
      }
    };
    fn = function(k) {
      var j, o, ref3, results;
      results = [];
      for (j = o = 0, ref3 = j_last; 0 <= ref3 ? o <= ref3 : o >= ref3; j = 0 <= ref3 ? ++o : --o) {
        results.push((function(j) {
          var faces, filter_pnts, flag, fn1, i, pnts, q, ref4, ref5, ref6, results1, results2, t, u;
          if (directions[0] && last_border_line(0, k, j, 0)) {
            pnts = [];
            faces = [];
            border_points(0, k, j, (function() {
              results1 = [];
              for (var q = 0; 0 <= i_last ? q <= i_last : q >= i_last; 0 <= i_last ? q++ : q--){ results1.push(q); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[0] && filter_last_border_line(0, k, j, 0) && borders[5][0] !== borders[5][1]) {
              pnts = [];
              faces = [];
              border_points(0, k, j, (function() {
                results2 = [];
                for (var t = ref4 = borders[5][0], ref5 = borders[5][1]; ref4 <= ref5 ? t <= ref5 : t >= ref5; ref4 <= ref5 ? t++ : t--){ results2.push(t); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
            }
            pnts = [];
            filter_pnts = [];
            flag = -1;
            fn1 = function(i) {
              if (filtered(k, j, i)) {
                if (flag === 1) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  add_seg(pnts, 0, k, j, 0);
                  pnts = [];
                }
                if (indexOf.call(filter_detail[0], k) >= 0 && indexOf.call(filter_detail[1], j) >= 0) {
                  filter_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 0;
              } else {
                if (flag === 0) {
                  add_seg(filter_pnts, 0, k, j, 0, true);
                  filter_pnts = [];
                  pnts.push(data[k][j][i - 1][0], data[k][j][i - 1][1], data[k][j][i - 1][2]);
                }
                if (indexOf.call(detail[0], k) >= 0 && indexOf.call(detail[1], j) >= 0) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 1;
              }
            };
            for (i = u = 0, ref6 = i_last; 0 <= ref6 ? u <= ref6 : u >= ref6; i = 0 <= ref6 ? ++u : --u) {
              fn1(i);
            }
            add_seg(pnts, 0, k, j, 0);
            return add_seg(filter_pnts, 0, k, j, 0, true);
          }
        })(j));
      }
      return results;
    };
    for (k = n = 0, ref2 = k_last; 0 <= ref2 ? n <= ref2 : n >= ref2; k = 0 <= ref2 ? ++n : --n) {
      fn(k);
    }
    fn1 = function(k) {
      var i, q, ref4, results;
      results = [];
      for (i = q = 0, ref4 = i_last; 0 <= ref4 ? q <= ref4 : q >= ref4; i = 0 <= ref4 ? ++q : --q) {
        results.push((function(i) {
          var faces, filter_pnts, flag, fn2, j, pnts, ref5, ref6, ref7, results1, results2, t, u, v;
          if (directions[1] && last_border_line(1, k, 0, i)) {
            pnts = [];
            faces = [];
            border_points(1, k, i, (function() {
              results1 = [];
              for (var t = 0; 0 <= j_last ? t <= j_last : t >= j_last; 0 <= j_last ? t++ : t--){ results1.push(t); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[1] && filter_last_border_line(1, k, 0, i) && borders[4][0] !== borders[4][1]) {
              pnts = [];
              faces = [];
              border_points(1, k, i, (function() {
                results2 = [];
                for (var u = ref5 = borders[4][0], ref6 = borders[4][1]; ref5 <= ref6 ? u <= ref6 : u >= ref6; ref5 <= ref6 ? u++ : u--){ results2.push(u); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
            }
            pnts = [];
            filter_pnts = [];
            flag = -1;
            fn2 = function(j) {
              if (filtered(k, j, i)) {
                if (flag === 1) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  add_seg(pnts, 1, k, 0, i);
                  pnts = [];
                }
                if (indexOf.call(filter_detail[0], k) >= 0 && indexOf.call(filter_detail[2], i) >= 0) {
                  filter_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 0;
              } else {
                if (flag === 0) {
                  add_seg(filter_pnts, 1, k, 0, i, true);
                  filter_pnts = [];
                  pnts.push(data[k][j - 1][i][0], data[k][j - 1][i][1], data[k][j - 1][i][2]);
                }
                if (indexOf.call(detail[0], k) >= 0 && indexOf.call(detail[2], i) >= 0) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 1;
              }
            };
            for (j = v = 0, ref7 = j_last; 0 <= ref7 ? v <= ref7 : v >= ref7; j = 0 <= ref7 ? ++v : --v) {
              fn2(j);
            }
            add_seg(pnts, 1, k, 0, i);
            return add_seg(filter_pnts, 1, k, 0, i, true);
          }
        })(i));
      }
      return results;
    };
    for (k = o = 0, ref3 = k_last; 0 <= ref3 ? o <= ref3 : o >= ref3; k = 0 <= ref3 ? ++o : --o) {
      fn1(k);
    }
    results = [];
    for (j = q = 0, ref4 = j_last; 0 <= ref4 ? q <= ref4 : q >= ref4; j = 0 <= ref4 ? ++q : --q) {
      results.push((function(j) {
        var i, ref5, results1, t;
        results1 = [];
        for (i = t = 0, ref5 = i_last; 0 <= ref5 ? t <= ref5 : t >= ref5; i = 0 <= ref5 ? ++t : --t) {
          results1.push((function(i) {
            var faces, filter_pnts, flag, fn2, pnts, ref6, ref7, ref8, results2, results3, u, v, w;
            if (directions[2] && last_border_line(2, 0, j, i)) {
              pnts = [];
              faces = [];
              border_points(2, j, i, (function() {
                results2 = [];
                for (var u = 0; 0 <= k_last ? u <= k_last : u >= k_last; 0 <= k_last ? u++ : u--){ results2.push(u); }
                return results2;
              }).apply(this), pnts, faces);
              return add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
            } else {
              if (filter_directions[2] && filter_last_border_line(2, 0, j, i) && borders[3][0] !== borders[3][1]) {
                pnts = [];
                faces = [];
                border_points(2, j, i, (function() {
                  results3 = [];
                  for (var v = ref6 = borders[3][0], ref7 = borders[3][1]; ref6 <= ref7 ? v <= ref7 : v >= ref7; ref6 <= ref7 ? v++ : v--){ results3.push(v); }
                  return results3;
                }).apply(this), pnts, faces);
                add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
              }
              pnts = [];
              filter_pnts = [];
              flag = -1;
              fn2 = function(k) {
                if (filtered(k, j, i)) {
                  if (flag === 1) {
                    pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                    add_seg(pnts, 2, 0, j, i);
                    pnts = [];
                  }
                  if (indexOf.call(filter_detail[1], j) >= 0 && indexOf.call(filter_detail[2], i) >= 0) {
                    filter_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  }
                  return flag = 0;
                } else {
                  if (flag === 0) {
                    add_seg(filter_pnts, 2, 0, j, i, true);
                    filter_pnts = [];
                    pnts.push(data[k - 1][j][i][0], data[k - 1][j][i][1], data[k - 1][j][i][2]);
                  }
                  if (indexOf.call(detail[1], j) >= 0 && indexOf.call(detail[2], i) >= 0) {
                    pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  }
                  return flag = 1;
                }
              };
              for (k = w = 0, ref8 = k_last; 0 <= ref8 ? w <= ref8 : w >= ref8; k = 0 <= ref8 ? ++w : --w) {
                fn2(k);
              }
              add_seg(pnts, 2, 0, j, i);
              return add_seg(filter_pnts, 2, 0, j, i, true);
            }
          })(i));
        }
        return results1;
      })(j));
    }
    return results;
  };

  root.gen_surfaces = function(data, scale_coeff, det, dir, mat, filter, filter_directions, filter_materials, filter_scalar) {
    var compare, detail, directions, filter_internal, fn, fn1, get_segment, i, i_first, i_last, i_lst_back, i_lst_filter, i_lst_front, i_lst_main, i_part, i_size, internal_area, j_first, j_last, j_lst_back, j_lst_filter, j_lst_front, j_lst_main, j_part, j_size, k, k_first, k_index, k_last, k_lst_back, k_lst_filter, k_lst_front, k_lst_main, k_part, k_size, len, materials, merge, n, o, q, results, vec;
    if (filter == null) {
      filter = [];
    }
    if (filter_directions == null) {
      filter_directions = [];
    }
    if (filter_materials == null) {
      filter_materials = [];
    }
    if (filter_scalar == null) {
      filter_scalar = [];
    }
    if (filter.length < 3 && filter_directions.length < 3) {
      filter_directions = [false, false, false];
    }
    k_first = 0;
    j_first = 0;
    i_first = 0;
    if (filter.length < 3 && (!dir[0] && !dir[1] && dir[2])) {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[j][i][k][0], data[j][i][k][1], data[j][i][k][2]);
      };
      detail = [det[2], det[0], det[1]];
      directions = [dir[2], dir[0], dir[1]];
      materials = [mat[2], mat[0], mat[1]];
      k_last = data[0][0].length - 1;
      j_last = data.length - 1;
      i_last = data[0].length - 1;
    } else if (filter.length < 3 && ((!dir[0] && dir[1] && !dir[2]) || (!dir[0] && dir[1] && dir[2]))) {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[i][k][j][0], data[i][k][j][1], data[i][k][j][2]);
      };
      detail = [det[1], det[2], det[0]];
      directions = [dir[1], dir[2], dir[0]];
      materials = [mat[1], mat[2], mat[0]];
      k_last = data[0].length - 1;
      j_last = data[0][0].length - 1;
      i_last = data.length - 1;
    } else {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
      };
      detail = [det[0], det[1], det[2]];
      directions = [dir[0], dir[1], dir[2]];
      materials = [mat[0], mat[1], mat[2]];
      k_last = data.length - 1;
      j_last = data[0].length - 1;
      i_last = data[0][0].length - 1;
    }
    get_segment = function(l, r, step) {
      var fn, lst, n, ref, ref1, ref2, x;
      lst = [];
      fn = function(x) {
        return lst.push(x);
      };
      for (x = n = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? n <= ref1 : n >= ref1; x = n += ref2) {
        fn(x);
      }
      if (lst[lst.length - 1] !== r) {
        lst.push(r);
      }
      return lst;
    };
    if (filter.length > 2) {
      fn = function(i) {
        var f;
        if (filter[i][0] < 0) {
          filter[i][0] = 0;
        }
        if (filter[i][1] < 0) {
          filter[i][1] = 0;
        }
        if (filter[i][2] < 1) {
          filter[i][2] = 1;
        }
        if (filter[i][0] > filter[i][1]) {
          f = filter[i][0];
          filter[i][0] = filter[i][1];
          return filter[i][1] = f;
        }
      };
      for (i = n = 0; n <= 2; i = ++n) {
        fn(i);
      }
      fn1 = function(i) {
        if (filter[0][i] > k_last) {
          filter[0][i] = k_last;
        }
        if (filter[1][i] > j_last) {
          filter[1][i] = j_last;
        }
        if (filter[2][i] > i_last) {
          return filter[2][i] = i_last;
        }
      };
      for (i = o = 0; o <= 2; i = ++o) {
        fn1(i);
      }
    }
    if (filter.length > 2 && filter_materials.length > 2) {
      k_lst_main = get_segment(k_first, k_last, detail[0]);
      j_lst_main = get_segment(j_first, j_last, detail[1]);
      i_lst_main = get_segment(i_first, i_last, detail[2]);
      k_lst_filter = get_segment(filter[0][0], filter[0][1], filter[0][2]);
      j_lst_filter = get_segment(filter[1][0], filter[1][1], filter[1][2]);
      i_lst_filter = get_segment(filter[2][0], filter[2][1], filter[2][2]);
      merge = function(a, b) {
        return a.concat(b.filter(function(x) {
          return a.indexOf(x) < 0;
        }));
      };
      k_lst_front = merge(k_lst_main, k_lst_filter);
      j_lst_front = merge(j_lst_main, j_lst_filter);
      i_lst_front = merge(i_lst_main, i_lst_filter);
      compare = function(a, b) {
        return a - b;
      };
      k_lst_front.sort(compare);
      j_lst_front.sort(compare);
      i_lst_front.sort(compare);
      k_lst_back = k_lst_front.slice();
      j_lst_back = j_lst_front.slice();
      i_lst_back = i_lst_front.slice();
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
      filter_internal = true;
    } else {
      if (filter.length > 2) {
        k_first = filter[0][0];
        j_first = filter[1][0];
        i_first = filter[2][0];
        k_last = filter[0][1];
        j_last = filter[1][1];
        i_last = filter[2][1];
        detail = [filter[0][2], filter[1][2], filter[2][2]];
      }
      k_lst_front = get_segment(k_first, k_last, detail[0]);
      j_lst_front = get_segment(j_first, j_last, detail[1]);
      i_lst_front = get_segment(i_first, i_last, detail[2]);
      k_lst_back = get_segment(k_first, k_last, detail[0]);
      j_lst_back = get_segment(j_first, j_last, detail[1]);
      i_lst_back = get_segment(i_first, i_last, detail[2]);
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
    }
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    if (k_size < 1) {
      k_size = 1;
    }
    if (j_size < 1) {
      j_size = 1;
    }
    if (i_size < 1) {
      i_size = 1;
    }
    internal_area = function(dir, k, j, i) {
      var f1, f2, f3;
      f1 = f2 = f3 = true;
      if (dir !== 0) {
        f1 = k >= filter[0][0] && k < filter[0][1] ? true : false;
      }
      if (dir !== 1) {
        f2 = j >= filter[1][0] && j < filter[1][1] ? true : false;
      }
      if (dir !== 2) {
        f3 = i >= filter[2][0] && i < filter[2][1] ? true : false;
      }
      return f1 && f2 && f3;
    };
    if (filter_scalar.length) {
      root.scalar = filter_scalar[0] + 2;
      internal_area = function(dir, k, j, i) {
        var ci_lst, cj_lst, ck, ck_lst, fn2, len, q, res;
        res = false;
        ck_lst = dir !== 1 && dir !== 2 && k > 0 ? [-1, 0] : [0];
        cj_lst = dir !== 0 && dir !== 2 && j > 0 ? [-1, 0] : [0];
        ci_lst = dir !== 0 && dir !== 1 && i > 0 ? [-1, 0] : [0];
        if (k + 1 === data.length - 1) {
          ck_lst.push(1);
        }
        if (j + 1 === data[0].length - 1) {
          cj_lst.push(1);
        }
        if (i + 1 === data[0][0].length - 1) {
          ci_lst.push(1);
        }
        fn2 = function(ck) {
          var cj, len1, results, t;
          results = [];
          for (t = 0, len1 = cj_lst.length; t < len1; t++) {
            cj = cj_lst[t];
            results.push((function(cj) {
              var ci, len2, results1, u;
              results1 = [];
              for (u = 0, len2 = ci_lst.length; u < len2; u++) {
                ci = ci_lst[u];
                results1.push((function(ci) {
                  var value;
                  value = data[k + ck][j + cj][i + ci][scalar];
                  if (value >= filter_scalar[1][0] && value <= filter_scalar[1][1]) {
                    return res = true;
                  }
                })(ci));
              }
              return results1;
            })(cj));
          }
          return results;
        };
        for (q = 0, len = ck_lst.length; q < len; q++) {
          ck = ck_lst[q];
          fn2(ck);
        }
        return res;
      };
    }
    i_part = function(dir, i_index, k1, k2, j1, j2) {
      var faces, faces_internal, fn2, fn3, get_face_0, get_face_1, j_index_size, k, k_index_size, q, ref, ref1, ref2, t, vertices;
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
        i = i_lst_back[i_index];
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
        i = i_lst_front[i_index];
      }
      k_index_size = k2 - k1;
      j_index_size = j2 - j1;
      if (k1 !== k2 && j1 !== j2) {
        vertices = [];
        fn2 = function(k) {
          var j, ref2, ref3, results, t;
          results = [];
          for (j = t = ref2 = j1, ref3 = j2; ref2 <= ref3 ? t <= ref3 : t >= ref3; j = ref2 <= ref3 ? ++t : --t) {
            results.push((function(j) {
              return vertices.push(vec(k, j, i));
            })(j));
          }
          return results;
        };
        for (k = q = ref = k1, ref1 = k2; ref <= ref1 ? q <= ref1 : q >= ref1; k = ref <= ref1 ? ++q : --q) {
          fn2(k);
        }
        faces = [];
        faces_internal = [];
        fn3 = function(k) {
          var j, ref3, results, u;
          results = [];
          for (j = u = 0, ref3 = j_index_size - 1; 0 <= ref3 ? u <= ref3 : u >= ref3; j = 0 <= ref3 ? ++u : --u) {
            results.push((function(j) {
              var a, b, face_0, face_1, j0, k0;
              a = (j_index_size + 1) * k + j;
              b = (j_index_size + 1) * (k + 1) + j;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if ((filter_internal && i >= filter[2][0] && i <= filter[2][1]) || filter_scalar.length) {
                k0 = k + k1;
                j0 = j + j1;
                if (internal_area(2, k0, j0, i)) {
                  if (filter_scalar.length || (indexOf.call(i_lst_filter, i) >= 0)) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if (filter_scalar.length || (indexOf.call(i_lst_main, i) >= 0)) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(j));
          }
          return results;
        };
        for (k = t = 0, ref2 = k_index_size - 1; 0 <= ref2 ? t <= ref2 : t >= ref2; k = 0 <= ref2 ? ++t : --t) {
          fn3(k);
        }
        if (faces.length > 0 && directions[2]) {
          add_surface(vertices, scale_coeff, faces, materials[2], 2);
        }
        if ((filter_internal || filter_scalar.length) && faces_internal.length > 0 && filter_directions[2]) {
          return add_surface(vertices, scale_coeff, faces_internal, filter_materials[2], 5);
        }
      }
    };
    j_part = function(dir, j_index, k1, k2) {
      var aa, ab, ac, faces, faces_internal, fn2, fn3, fn4, fn5, fn6, fn7, fn8, fn9, get_face_0, get_face_1, i_index, j, j1, j2, k, k_index_size, len, len1, len2, len3, len4, len5, len6, len7, q, ref, ref1, ref2, results, results1, t, u, v, vertices, w, y, z;
      if (dir !== 0) {
        if (j_index > 0) {
          j1 = j_lst_front[j_index - 1];
          j2 = j_lst_front[j_index];
          if (j_index >= j_lst_front.length / 2) {
            fn2 = function(i) {
              if (i_index >= i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = q = 0, len = i_lst_front.length; q < len; i_index = ++q) {
              i = i_lst_front[i_index];
              fn2(i);
            }
            fn3 = function(i) {
              if (i_index > i_lst_front.length / 2) {
                return i_part(0, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = t = 0, len1 = i_lst_back.length; t < len1; i_index = ++t) {
              i = i_lst_back[i_index];
              fn3(i);
            }
          } else {
            fn4 = function(i) {
              if (i_index < i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = u = 0, len2 = i_lst_front.length; u < len2; i_index = ++u) {
              i = i_lst_front[i_index];
              fn4(i);
            }
            fn5 = function(i) {
              if (i_index <= i_lst_front.length / 2) {
                return i_part(0, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = v = 0, len3 = i_lst_back.length; v < len3; i_index = ++v) {
              i = i_lst_back[i_index];
              fn5(i);
            }
          }
        }
      }
      j = j_lst_front[j_index];
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
      }
      k_index_size = k2 - k1;
      if (k1 !== k2 && i_first !== i_last) {
        vertices = [];
        fn6 = function(k) {
          var ref2, ref3, results, y;
          results = [];
          for (i = y = ref2 = i_first, ref3 = i_last; ref2 <= ref3 ? y <= ref3 : y >= ref3; i = ref2 <= ref3 ? ++y : --y) {
            results.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results;
        };
        for (k = w = ref = k1, ref1 = k2; ref <= ref1 ? w <= ref1 : w >= ref1; k = ref <= ref1 ? ++w : --w) {
          fn6(k);
        }
        faces = [];
        faces_internal = [];
        fn7 = function(k) {
          var ref3, results, z;
          results = [];
          for (i = z = 0, ref3 = i_size - 1; 0 <= ref3 ? z <= ref3 : z >= ref3; i = 0 <= ref3 ? ++z : --z) {
            results.push((function(i) {
              var a, b, face_0, face_1, k0;
              a = (i_size + 1) * k + i;
              b = (i_size + 1) * (k + 1) + i;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && j >= filter[1][0] && j <= filter[1][1] || filter_scalar.length) {
                k0 = k + k1;
                if (internal_area(1, k0, j, i)) {
                  if (filter_scalar.length || (indexOf.call(j_lst_filter, j) >= 0)) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if (filter_scalar.length || (indexOf.call(j_lst_main, j) >= 0)) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results;
        };
        for (k = y = 0, ref2 = k_index_size - 1; 0 <= ref2 ? y <= ref2 : y >= ref2; k = 0 <= ref2 ? ++y : --y) {
          fn7(k);
        }
        if (faces.length > 0 && directions[1]) {
          add_surface(vertices, scale_coeff, faces, materials[1], 1);
        }
        if ((filter_internal || filter_scalar.length) && faces_internal.length > 0 && filter_directions[1]) {
          add_surface(vertices, scale_coeff, faces_internal, filter_materials[1], 4);
        }
      }
      if (dir !== 1) {
        if (j_index > 0) {
          j1 = j_lst_front[j_index - 1];
          j2 = j_lst_front[j_index];
          if (j_index >= j_lst_front.length / 2) {
            fn8 = function(i) {
              if (i_index < i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = z = 0, len4 = i_lst_front.length; z < len4; i_index = ++z) {
              i = i_lst_front[i_index];
              fn8(i);
            }
            results = [];
            for (i_index = aa = 0, len5 = i_lst_back.length; aa < len5; i_index = ++aa) {
              i = i_lst_back[i_index];
              results.push((function(i) {
                if (i_index <= i_lst_front.length / 2) {
                  return i_part(0, i_index, k1, k2, j1, j2);
                }
              })(i));
            }
            return results;
          } else {
            fn9 = function(i) {
              if (i_index >= i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = ab = 0, len6 = i_lst_front.length; ab < len6; i_index = ++ab) {
              i = i_lst_front[i_index];
              fn9(i);
            }
            results1 = [];
            for (i_index = ac = 0, len7 = i_lst_back.length; ac < len7; i_index = ++ac) {
              i = i_lst_back[i_index];
              results1.push((function(i) {
                if (i_index > i_lst_front.length / 2) {
                  return i_part(0, i_index, k1, k2, j1, j2);
                }
              })(i));
            }
            return results1;
          }
        }
      }
    };
    k_part = function(dir, k_index) {
      var faces, faces_internal, fn2, fn3, fn4, get_face_0, get_face_1, j, j_index, k, k1, k2, len, len1, q, ref, ref1, ref2, results, t, u, v, vertices;
      if (dir !== 0 && k_index > 0) {
        k1 = k_lst_front[k_index - 1];
        k2 = k_lst_front[k_index];
        if (k_index >= k_lst_front.length / 2) {
          fn2 = function(j) {
            j_part(0, j_lst_front.length - 1 - j_index, k1, k2);
            return j_part(1, j_index, k1, k2);
          };
          for (j_index = q = 0, len = j_lst_front.length; q < len; j_index = ++q) {
            j = j_lst_front[j_index];
            fn2(j);
          }
        }
      }
      k = k_lst_front[k_index];
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
      }
      if (j_first !== j_last && i_first !== i_last) {
        vertices = [];
        fn3 = function(j) {
          var ref2, ref3, results, u;
          results = [];
          for (i = u = ref2 = i_first, ref3 = i_last; ref2 <= ref3 ? u <= ref3 : u >= ref3; i = ref2 <= ref3 ? ++u : --u) {
            results.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results;
        };
        for (j = t = ref = j_first, ref1 = j_last; ref <= ref1 ? t <= ref1 : t >= ref1; j = ref <= ref1 ? ++t : --t) {
          fn3(j);
        }
        faces = [];
        faces_internal = [];
        fn4 = function(j) {
          var ref3, results, v;
          results = [];
          for (i = v = 0, ref3 = i_size - 1; 0 <= ref3 ? v <= ref3 : v >= ref3; i = 0 <= ref3 ? ++v : --v) {
            results.push((function(i) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && k >= filter[0][0] && k <= filter[0][1] || filter_scalar.length) {
                if (internal_area(0, k, j, i)) {
                  if (filter_scalar.length || (indexOf.call(k_lst_filter, k) >= 0)) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if (filter_scalar.length || (indexOf.call(k_lst_main, k) >= 0)) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results;
        };
        for (j = u = 0, ref2 = j_size - 1; 0 <= ref2 ? u <= ref2 : u >= ref2; j = 0 <= ref2 ? ++u : --u) {
          fn4(j);
        }
        if (faces.length > 0 && directions[0]) {
          add_surface(vertices, scale_coeff, faces, materials[0], 0);
        }
        if ((filter_internal || filter_scalar.length) && faces_internal.length > 0 && filter_directions[0]) {
          add_surface(vertices, scale_coeff, faces_internal, filter_materials[0], 3);
        }
      }
      if (dir !== 1 && k_index > 0) {
        k1 = k_lst_front[k_index - 1];
        k2 = k_lst_front[k_index];
        if (k_index < k_lst_front.length / 2) {
          results = [];
          for (j_index = v = 0, len1 = j_lst_front.length; v < len1; j_index = ++v) {
            j = j_lst_front[j_index];
            results.push((function(j) {
              j_part(0, j_lst_front.length - 1 - j_index, k1, k2);
              return j_part(1, j_index, k1, k2);
            })(j));
          }
          return results;
        }
      }
    };
    results = [];
    for (k_index = q = 0, len = k_lst_front.length; q < len; k_index = ++q) {
      k = k_lst_front[k_index];
      results.push((function(k) {
        k_part(1, k_index);
        return k_part(0, k_lst_front.length - 1 - k_index);
      })(k));
    }
    return results;
  };

  root.add_line = function(pnts, scale_coeff, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(pnts), 3));
    geometry.computeBoundingSphere();
    geometry.computeLineDistances();
    sceneObject = new THREE.Line(geometry, material);
    sceneObject.name = name;
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return root.lines.add(sceneObject);
  };

  root.add_border_line = function(vertices, scale_coeff, faces, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.name = name;
    return root.lines.add(sceneObject);
  };

  root.add_surface = function(vertices, scale_coeff, faces, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.name = name;
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return root.faces.add(sceneObject);
  };

  root.GridLines = {
    init: function(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials, filter_scalar) {
      var borders, d, filter_d, filtered, fn, fn1, get_segment, i, n, o;
      root.lines = new THREE.Object3D();
      root.k_last = data.length - 1;
      root.j_last = data[0].length - 1;
      root.i_last = data[0][0].length - 1;
      get_segment = function(l, r, step) {
        var fn, lst, n, ref, ref1, ref2, x;
        lst = [];
        fn = function(x) {
          return lst.push(x);
        };
        for (x = n = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? n <= ref1 : n >= ref1; x = n += ref2) {
          fn(x);
        }
        if (lst[lst.length - 1] !== r) {
          lst.push(r);
        }
        return lst;
      };
      d = [get_segment(0, k_last, detail[0]), get_segment(0, j_last, detail[1]), get_segment(0, i_last, detail[2])];
      if (filter.length > 0) {
        fn = function(i) {
          var f;
          if (filter[i][0] < 0) {
            filter[i][0] = 0;
          }
          if (filter[i][1] < 0) {
            filter[i][1] = 0;
          }
          if (filter[i][2] < 1) {
            filter[i][2] = 1;
          }
          if (filter[i][0] > filter[i][1]) {
            f = filter[i][0];
            filter[i][0] = filter[i][1];
            return filter[i][1] = f;
          }
        };
        for (i = n = 0; n <= 2; i = ++n) {
          fn(i);
        }
        fn1 = function(i) {
          if (filter[0][i] > k_last) {
            filter[0][i] = k_last;
          }
          if (filter[1][i] > j_last) {
            filter[1][i] = j_last;
          }
          if (filter[2][i] > i_last) {
            return filter[2][i] = i_last;
          }
        };
        for (i = o = 0; o <= 2; i = ++o) {
          fn1(i);
        }
        root.filter_k_segment = get_segment(filter[0][0], filter[0][1], filter[0][2]);
        root.filter_j_segment = get_segment(filter[1][0], filter[1][1], filter[1][2]);
        root.filter_i_segment = get_segment(filter[2][0], filter[2][1], filter[2][2]);
        filtered = function(k, j, i) {
          if (k >= filter[0][0] && k <= filter[0][1] && j >= filter[1][0] && j <= filter[1][1] && i >= filter[2][0] && i <= filter[2][1]) {
            return true;
          } else {
            return false;
          }
        };
        filter_d = [filter_k_segment, filter_j_segment, filter_i_segment];
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1], [filter[0][0], filter[0][1]], [filter[1][0], filter[1][1]], [filter[2][0], filter[2][1]]];
      } else if (filter_scalar.length) {
        root.scalar = filter_scalar[0] + 2;
        filtered = function(k, j, i) {
          var ci_lst, cj_lst, ck, ck_lst, fn2, len, q, res;
          res = false;
          ck_lst = k > 0 ? [-1, 0] : [0];
          cj_lst = j > 0 ? [-1, 0] : [0];
          ci_lst = i > 0 ? [-1, 0] : [0];
          if (k + 1 === k_last) {
            ck_lst.push(1);
          }
          if (j + 1 === j_last) {
            cj_lst.push(1);
          }
          if (i + 1 === i_last) {
            ci_lst.push(1);
          }
          fn2 = function(ck) {
            var cj, len1, results, t;
            results = [];
            for (t = 0, len1 = cj_lst.length; t < len1; t++) {
              cj = cj_lst[t];
              results.push((function(cj) {
                var ci, len2, results1, u;
                results1 = [];
                for (u = 0, len2 = ci_lst.length; u < len2; u++) {
                  ci = ci_lst[u];
                  results1.push((function(ci) {
                    var value;
                    value = data[k + ck][j + cj][i + ci][scalar];
                    if (value >= filter_scalar[1][0] && value <= filter_scalar[1][1]) {
                      return res = true;
                    }
                  })(ci));
                }
                return results1;
              })(cj));
            }
            return results;
          };
          for (q = 0, len = ck_lst.length; q < len; q++) {
            ck = ck_lst[q];
            fn2(ck);
          }
          return res;
        };
        filter_d = d;
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
      } else {
        filtered = function(k, j, i) {
          return false;
        };
        filter_d = [[], [], []];
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
      }
      gen_lines(data, scale_coeff, d, directions, materials, borders, filtered, filter_d, filter_directions, filter_materials);
      return root.lines;
    }
  };

  root.GridFaces = {
    init: function(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials, filter_scalar) {
      var n1, n2, n3;
      root.faces = new THREE.Object3D();
      if (directions.length < 3) {
        directions = [false, false, false];
      }
      if (filter_directions.length < 3) {
        filter_directions = [true, true, true];
      }
      if (filter.length === 0 && filter_scalar.length === 0) {
        gen_surfaces(data, scale_coeff, detail, directions, materials);
      } else if (filter.length > 2) {
        n1 = filter[0][0] !== filter[0][1] ? true : false;
        n2 = filter[1][0] !== filter[1][1] ? true : false;
        n3 = filter[2][0] !== filter[2][1] ? true : false;
        if ((n1 && n2) || (n1 && n3) || (n2 && n3)) {
          if (directions[0] || directions[1] || directions[2]) {
            gen_surfaces(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials);
          } else {
            gen_surfaces(data, scale_coeff, detail, filter_directions, filter_materials, filter);
          }
        }
      } else {
        gen_surfaces(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials, filter_scalar);
      }
      return root.faces;
    }
  };

  root.GridPoints = {
    init: function(data, scale_coeff, variable, min, max, index, color, radius, options, types) {
      var calc_color, colors, fn, fn1, fn2, geometry, h, i, k, k_index, key, key_index, keys, len, len1, material, n, o, paletter, positions, q, ref, v0, v1;
      geometry = new THREE.BufferGeometry();
      root.cubes = new THREE.Object3D();
      paletter = [];
      fn = function(i) {
        return paletter.push(parseInt(color[i].substring(1), 16));
      };
      for (i = n = 0, ref = color.length - 1; 0 <= ref ? n <= ref : n >= ref; i = 0 <= ref ? ++n : --n) {
        fn(i);
      }
      variable = parseInt(variable) + 2;
      v0 = min[variable];
      v1 = max[variable];
      if (types.length > variable - 3 && !!types[variable - 3]) {
        h = types[variable - 3];
        keys = Object.keys(h);
        fn1 = function(key) {
          return h[key] = paletter[key_index];
        };
        for (key_index = o = 0, len = keys.length; o < len; key_index = ++o) {
          key = keys[key_index];
          fn1(key);
        }
        calc_color = function(value) {
          var b, c, g, r;
          c = h[value];
          r = c >> 16;
          g = (c & 0x00ff00) >> 8;
          b = c & 0x0000ff;
          return [r, g, b];
        };
      } else {
        calc_color = function(value) {
          var b, b0, b1, coeff, coeff_0, coeff_int, g, g0, g1, r, r0, r1;
          coeff = (value - v0) / (v1 - v0);
          coeff_int = Math.floor(coeff * (paletter.length - 1));
          r0 = paletter[coeff_int] >> 16;
          g0 = (paletter[coeff_int] & 0x00ff00) >> 8;
          b0 = paletter[coeff_int] & 0x0000ff;
          if (coeff_int === paletter.length - 1) {
            r = r0;
            g = g0;
            b = b0;
          } else {
            r1 = paletter[coeff_int + 1] >> 16;
            g1 = (paletter[coeff_int + 1] & 0x00ff00) >> 8;
            b1 = paletter[coeff_int + 1] & 0x0000ff;
            coeff_0 = coeff * (paletter.length - 1) - coeff_int;
            r = (r1 - r0) * coeff_0 + r0;
            g = (g1 - g0) * coeff_0 + g0;
            b = (b1 - b0) * coeff_0 + b0;
          }
          return [r, g, b];
        };
      }
      positions = [];
      colors = [];
      fn2 = function(k) {
        var j, j_index, len2, results, t;
        results = [];
        for (j_index = t = 0, len2 = k.length; t < len2; j_index = ++t) {
          j = k[j_index];
          results.push((function(j) {
            var i_index, len3, results1, u;
            results1 = [];
            for (i_index = u = 0, len3 = j.length; u < len3; i_index = ++u) {
              i = j[i_index];
              results1.push((function(i) {
                var b, g, r, ref1, sprite, sprite_material;
                if (options[0] || k_index === 0 || k_index === data.length - 1 || j_index === 0 || j_index === k.length - 1 || i_index === 0 || i_index === j.length - 1) {
                  positions.push(i[0], i[1], i[2]);
                  ref1 = calc_color(i[variable]), r = ref1[0], g = ref1[1], b = ref1[2];
                  colors.push(r / 255, g / 255, b / 255);
                  sprite_material = new THREE.SpriteMaterial({
                    color: (r << 16) + (g << 8) + b
                  });
                  sprite = new THREE.Sprite(sprite_material);
                  sprite.position.x = i[0] * scale_coeff;
                  sprite.position.y = i[1] * scale_coeff;
                  sprite.position.z = i[2] * scale_coeff;
                  sprite.scale.set(radius * 0.7, radius * 0.7, 1);
                  return root.cubes.add(sprite);
                }
              })(i));
            }
            return results1;
          })(j));
        }
        return results;
      };
      for (k_index = q = 0, len1 = data.length; q < len1; k_index = ++q) {
        k = data[k_index];
        fn2(k);
      }
      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
      material = new THREE.PointsMaterial({
        vertexColors: THREE.VertexColors,
        size: radius * 2,
        sizeAttenuation: true
      });
      root.points = new THREE.Points(geometry, material);
      root.points.scale.set(scale_coeff, scale_coeff, scale_coeff);
      root.points.sortParticles = true;
      return [root.points, root.cubes];
    }
  };

}).call(this);
