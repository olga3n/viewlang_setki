// Generated by CoffeeScript 1.10.0
(function() {
  var root,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.gen_lines = function(data, scale_coeff, lst, directions, materials, filter) {
    var border_color, border_line, borders, calc_material, coeff, fn, fn1, i_first, i_last, i_lst, i_seg, i_size, j, j_first, j_last, j_lst, j_seg, j_size, k, k_first, k_last, k_lst, k_seg, k_size, last_border_line, len, len1, len2, n, o, p, q, results, results1, results2, results3, s, t;
    if (filter == null) {
      filter = false;
    }
    if (directions.length < 4) {
      directions = [true, true, true, true];
    }
    k_lst = lst[0];
    j_lst = lst[1];
    i_lst = lst[2];
    k_first = k_lst[0];
    j_first = j_lst[0];
    i_first = i_lst[0];
    k_last = k_lst[k_lst.length - 1];
    j_last = j_lst[j_lst.length - 1];
    i_last = i_lst[i_lst.length - 1];
    k_seg = (function() {
      results = [];
      for (var n = k_first; k_first <= k_last ? n <= k_last : n >= k_last; k_first <= k_last ? n++ : n--){ results.push(n); }
      return results;
    }).apply(this);
    j_seg = (function() {
      results1 = [];
      for (var o = j_first; j_first <= j_last ? o <= j_last : o >= j_last; j_first <= j_last ? o++ : o--){ results1.push(o); }
      return results1;
    }).apply(this);
    i_seg = (function() {
      results2 = [];
      for (var p = i_first; i_first <= i_last ? p <= i_last : p >= i_last; i_first <= i_last ? p++ : p--){ results2.push(p); }
      return results2;
    }).apply(this);
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    if (filter === true) {
      borders = [[k_first, k_last], [j_first, j_last], [i_first, i_last]];
      coeff = 5;
      border_color = "#0000ff";
    } else {
      borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
      coeff = 0;
      border_color = "#000000";
    }
    last_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    if (materials.length < 4) {
      calc_material = function(dir, k, j, i) {
        var color, i_coeff, j_coeff, k_coeff, m, mid;
        if (last_border_line(dir, k, j, i)) {
          m = [
            new THREE.LineBasicMaterial({
              color: border_color,
              linewidth: 2.5
            }), coeff + 4
          ];
        } else if (border_line(dir, k, j, i)) {
          m = [
            new THREE.LineBasicMaterial({
              color: border_color,
              linewidth: 1
            }), coeff + 3
          ];
        } else {
          mid = filter === true ? 0xff : 0x88;
          i_coeff = dir === 0 ? mid : (i - i_first) / i_size * 0xff;
          j_coeff = dir === 1 ? mid : (j - j_first) / j_size * 0xff;
          k_coeff = dir === 2 ? mid : (k - k_first) / k_size * 0xff;
          color = (i_coeff << 16) + (j_coeff << 8) + k_coeff;
          m = [
            new THREE.LineBasicMaterial({
              color: color,
              linewidth: 1
            }), dir + coeff
          ];
        }
        return m;
      };
    } else {
      calc_material = function(dir, k, j, i) {
        var m;
        if (last_border_line(dir, k, j, i)) {
          m = [materials[4], coeff + 4];
        } else if (border_line(dir, k, j, i)) {
          m = [materials[3], coeff + 3];
        } else {
          m = directions[3] ? [materials[dir], dir + coeff] : [];
        }
        return m;
      };
    }
    if (directions[0]) {
      fn = function(k) {
        var j, len1, results3, s;
        results3 = [];
        for (s = 0, len1 = j_lst.length; s < len1; s++) {
          j = j_lst[s];
          results3.push((function(j) {
            var fn1, i, len2, m, pnts, t;
            pnts = [];
            fn1 = function(i) {
              return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
            };
            for (t = 0, len2 = i_seg.length; t < len2; t++) {
              i = i_seg[t];
              fn1(i);
            }
            m = calc_material(0, k, j, 0);
            if (m.length > 1) {
              return add_line(pnts, scale_coeff, m[0], m[1]);
            }
          })(j));
        }
        return results3;
      };
      for (q = 0, len = k_lst.length; q < len; q++) {
        k = k_lst[q];
        fn(k);
      }
    }
    if (directions[1]) {
      fn1 = function(k) {
        var i, len2, results3, t;
        results3 = [];
        for (t = 0, len2 = i_lst.length; t < len2; t++) {
          i = i_lst[t];
          results3.push((function(i) {
            var fn2, j, len3, m, pnts, u;
            pnts = [];
            fn2 = function(j) {
              return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
            };
            for (u = 0, len3 = j_seg.length; u < len3; u++) {
              j = j_seg[u];
              fn2(j);
            }
            m = calc_material(1, k, 0, i);
            if (m.length > 1) {
              return add_line(pnts, scale_coeff, m[0], m[1]);
            }
          })(i));
        }
        return results3;
      };
      for (s = 0, len1 = k_lst.length; s < len1; s++) {
        k = k_lst[s];
        fn1(k);
      }
    }
    if (directions[2]) {
      results3 = [];
      for (t = 0, len2 = j_lst.length; t < len2; t++) {
        j = j_lst[t];
        results3.push((function(j) {
          var i, len3, results4, u;
          results4 = [];
          for (u = 0, len3 = i_lst.length; u < len3; u++) {
            i = i_lst[u];
            results4.push((function(i) {
              var fn2, len4, m, pnts, v;
              pnts = [];
              fn2 = function(k) {
                return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
              };
              for (v = 0, len4 = k_seg.length; v < len4; v++) {
                k = k_seg[v];
                fn2(k);
              }
              m = calc_material(2, 0, j, i);
              if (m.length > 1) {
                return add_line(pnts, scale_coeff, m[0], m[1]);
              }
            })(i));
          }
          return results4;
        })(j));
      }
      return results3;
    }
  };

  root.gen_surfaces = function(data, scale_coeff, det, dir, mat, filter, filter_directions, filter_materials) {
    var compare, detail, directions, filter_internal, fn, fn1, get_segment, i, i_first, i_last, i_lst_back, i_lst_filter, i_lst_front, i_lst_main, i_part, i_size, internal_area, j_first, j_last, j_lst_back, j_lst_filter, j_lst_front, j_lst_main, j_part, j_size, k, k_first, k_index, k_last, k_lst_back, k_lst_filter, k_lst_front, k_lst_main, k_part, k_size, len, materials, merge, n, o, p, results, vec;
    if (filter == null) {
      filter = [];
    }
    if (filter_directions == null) {
      filter_directions = [];
    }
    if (filter_materials == null) {
      filter_materials = [];
    }
    if (filter.length < 3 && filter_directions.length < 3) {
      filter_directions = [false, false, false];
    }
    k_first = 0;
    j_first = 0;
    i_first = 0;
    if (filter.length < 3 && (!dir[0] && !dir[1] && dir[2])) {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[j][i][k][0], data[j][i][k][1], data[j][i][k][2]);
      };
      detail = [det[1], det[2], det[0]];
      directions = [dir[2], dir[0], dir[1]];
      materials = [mat[2], mat[0], mat[1]];
      k_last = data[0][0].length - 1;
      j_last = data.length - 1;
      i_last = data[0].length - 1;
    } else if (filter.length < 3 && ((!dir[0] && dir[1] && !dir[2]) || (!dir[0] && dir[1] && dir[2]))) {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[i][k][j][0], data[i][k][j][1], data[i][k][j][2]);
      };
      detail = [det[2], det[0], det[1]];
      directions = [dir[1], dir[2], dir[0]];
      materials = [mat[1], mat[2], mat[0]];
      k_last = data[0].length - 1;
      j_last = data[0][0].length - 1;
      i_last = data.length - 1;
    } else {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
      };
      detail = [det[0], det[1], det[2]];
      directions = [dir[0], dir[1], dir[2]];
      materials = [mat[0], mat[1], mat[2]];
      k_last = data.length - 1;
      j_last = data[0].length - 1;
      i_last = data[0][0].length - 1;
    }
    get_segment = function(l, r, step) {
      var fn, lst, n, ref, ref1, ref2, x;
      lst = [];
      fn = function(x) {
        return lst.push(x);
      };
      for (x = n = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? n <= ref1 : n >= ref1; x = n += ref2) {
        fn(x);
      }
      if (lst[lst.length - 1] !== r) {
        lst.push(r);
      }
      return lst;
    };
    if (filter.length > 2) {
      fn = function(i) {
        var f;
        if (filter[i][0] < 0) {
          filter[i][0] = 0;
        }
        if (filter[i][1] < 0) {
          filter[i][1] = 0;
        }
        if (filter[i][2] < 1) {
          filter[i][2] = 1;
        }
        if (filter[i][0] > filter[i][1]) {
          f = filter[i][0];
          filter[i][0] = filter[i][1];
          return filter[i][1] = f;
        }
      };
      for (i = n = 0; n <= 2; i = ++n) {
        fn(i);
      }
      fn1 = function(i) {
        if (filter[0][i] > k_last) {
          filter[0][i] = k_last;
        }
        if (filter[1][i] > j_last) {
          filter[1][i] = j_last;
        }
        if (filter[2][i] > i_last) {
          return filter[2][i] = i_last;
        }
      };
      for (i = o = 0; o <= 2; i = ++o) {
        fn1(i);
      }
    }
    if (filter.length > 2 && filter_materials.length > 2) {
      k_lst_main = get_segment(k_first, k_last, detail[0]);
      j_lst_main = get_segment(j_first, j_last, detail[1]);
      i_lst_main = get_segment(i_first, i_last, detail[2]);
      k_lst_filter = get_segment(filter[0][0], filter[0][1], filter[0][2]);
      j_lst_filter = get_segment(filter[1][0], filter[1][1], filter[1][2]);
      i_lst_filter = get_segment(filter[2][0], filter[2][1], filter[2][2]);
      merge = function(a, b) {
        return a.concat(b.filter(function(x) {
          return a.indexOf(x) < 0;
        }));
      };
      k_lst_front = merge(k_lst_main, k_lst_filter);
      j_lst_front = merge(j_lst_main, j_lst_filter);
      i_lst_front = merge(i_lst_main, i_lst_filter);
      compare = function(a, b) {
        return a - b;
      };
      k_lst_front.sort(compare);
      j_lst_front.sort(compare);
      i_lst_front.sort(compare);
      k_lst_back = k_lst_front.slice();
      j_lst_back = j_lst_front.slice();
      i_lst_back = i_lst_front.slice();
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
      filter_internal = true;
    } else {
      if (filter.length > 2) {
        k_first = filter[0][0];
        j_first = filter[1][0];
        i_first = filter[2][0];
        k_last = filter[0][1];
        j_last = filter[1][1];
        i_last = filter[2][1];
        detail = [filter[0][2], filter[1][2], filter[2][2]];
      }
      k_lst_front = get_segment(k_first, k_last, detail[0]);
      j_lst_front = get_segment(j_first, j_last, detail[1]);
      i_lst_front = get_segment(i_first, i_last, detail[2]);
      k_lst_back = get_segment(k_first, k_last, detail[0]);
      j_lst_back = get_segment(j_first, j_last, detail[1]);
      i_lst_back = get_segment(i_first, i_last, detail[2]);
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
    }
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    if (k_size < 1) {
      k_size = 1;
    }
    if (j_size < 1) {
      j_size = 1;
    }
    if (i_size < 1) {
      i_size = 1;
    }
    internal_area = function(dir, k, j, i) {
      var f1, f2, f3;
      f1 = f2 = f3 = true;
      if (dir !== 0) {
        f1 = k >= filter[0][0] && k < filter[0][1] ? true : false;
      }
      if (dir !== 1) {
        f2 = j >= filter[1][0] && j < filter[1][1] ? true : false;
      }
      if (dir !== 2) {
        f3 = i >= filter[2][0] && i < filter[2][1] ? true : false;
      }
      return f1 && f2 && f3;
    };
    i_part = function(dir, i_index, k1, k2, j1, j2) {
      var faces, faces_internal, fn2, fn3, get_face_0, get_face_1, j_index_size, k, k_index_size, p, q, ref, ref1, ref2, vertices;
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
        i = i_lst_back[i_index];
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
        i = i_lst_front[i_index];
      }
      k_index_size = k2 - k1;
      j_index_size = j2 - j1;
      if (k1 !== k2 && j1 !== j2) {
        vertices = [];
        fn2 = function(k) {
          var j, q, ref2, ref3, results;
          results = [];
          for (j = q = ref2 = j1, ref3 = j2; ref2 <= ref3 ? q <= ref3 : q >= ref3; j = ref2 <= ref3 ? ++q : --q) {
            results.push((function(j) {
              return vertices.push(vec(k, j, i));
            })(j));
          }
          return results;
        };
        for (k = p = ref = k1, ref1 = k2; ref <= ref1 ? p <= ref1 : p >= ref1; k = ref <= ref1 ? ++p : --p) {
          fn2(k);
        }
        faces = [];
        faces_internal = [];
        fn3 = function(k) {
          var j, ref3, results, s;
          results = [];
          for (j = s = 0, ref3 = j_index_size - 1; 0 <= ref3 ? s <= ref3 : s >= ref3; j = 0 <= ref3 ? ++s : --s) {
            results.push((function(j) {
              var a, b, face_0, face_1, j0, k0;
              a = (j_index_size + 1) * k + j;
              b = (j_index_size + 1) * (k + 1) + j;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && i >= filter[2][0] && i <= filter[2][1]) {
                k0 = k + k1;
                j0 = j + j1;
                if (internal_area(2, k0, j0, i)) {
                  if (indexOf.call(i_lst_filter, i) >= 0) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if (indexOf.call(i_lst_main, i) >= 0) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(j));
          }
          return results;
        };
        for (k = q = 0, ref2 = k_index_size - 1; 0 <= ref2 ? q <= ref2 : q >= ref2; k = 0 <= ref2 ? ++q : --q) {
          fn3(k);
        }
        if (faces.length > 0 && directions[2]) {
          add_surface(vertices, scale_coeff, faces, materials[2], 2);
        }
        if (filter_internal && faces_internal.length > 0 && filter_directions[2]) {
          return add_surface(vertices, scale_coeff, faces_internal, filter_materials[2], 5);
        }
      }
    };
    j_part = function(dir, j_index, k1, k2) {
      var aa, faces, faces_internal, fn2, fn3, fn4, fn5, fn6, fn7, fn8, fn9, get_face_0, get_face_1, i_index, j, j1, j2, k, k_index_size, len, len1, len2, len3, len4, len5, len6, len7, p, q, ref, ref1, ref2, results, results1, s, t, u, v, vertices, w, y, z;
      if (dir !== 0) {
        if (j_index > 0) {
          j1 = j_lst_front[j_index - 1];
          j2 = j_lst_front[j_index];
          if (j_index >= j_lst_front.length / 2) {
            fn2 = function(i) {
              if (i_index >= i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = p = 0, len = i_lst_front.length; p < len; i_index = ++p) {
              i = i_lst_front[i_index];
              fn2(i);
            }
            fn3 = function(i) {
              if (i_index > i_lst_front.length / 2) {
                return i_part(0, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = q = 0, len1 = i_lst_back.length; q < len1; i_index = ++q) {
              i = i_lst_back[i_index];
              fn3(i);
            }
          } else {
            fn4 = function(i) {
              if (i_index < i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = s = 0, len2 = i_lst_front.length; s < len2; i_index = ++s) {
              i = i_lst_front[i_index];
              fn4(i);
            }
            fn5 = function(i) {
              if (i_index <= i_lst_front.length / 2) {
                return i_part(0, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = t = 0, len3 = i_lst_back.length; t < len3; i_index = ++t) {
              i = i_lst_back[i_index];
              fn5(i);
            }
          }
        }
      }
      j = j_lst_front[j_index];
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
      }
      k_index_size = k2 - k1;
      if (k1 !== k2 && i_first !== i_last) {
        vertices = [];
        fn6 = function(k) {
          var ref2, ref3, results, v;
          results = [];
          for (i = v = ref2 = i_first, ref3 = i_last; ref2 <= ref3 ? v <= ref3 : v >= ref3; i = ref2 <= ref3 ? ++v : --v) {
            results.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results;
        };
        for (k = u = ref = k1, ref1 = k2; ref <= ref1 ? u <= ref1 : u >= ref1; k = ref <= ref1 ? ++u : --u) {
          fn6(k);
        }
        faces = [];
        faces_internal = [];
        fn7 = function(k) {
          var ref3, results, w;
          results = [];
          for (i = w = 0, ref3 = i_size - 1; 0 <= ref3 ? w <= ref3 : w >= ref3; i = 0 <= ref3 ? ++w : --w) {
            results.push((function(i) {
              var a, b, face_0, face_1, k0;
              a = (i_size + 1) * k + i;
              b = (i_size + 1) * (k + 1) + i;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && j >= filter[1][0] && j <= filter[1][1]) {
                k0 = k + k1;
                if (internal_area(1, k0, j, i)) {
                  if (indexOf.call(j_lst_filter, j) >= 0) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if (indexOf.call(j_lst_main, j) >= 0) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results;
        };
        for (k = v = 0, ref2 = k_index_size - 1; 0 <= ref2 ? v <= ref2 : v >= ref2; k = 0 <= ref2 ? ++v : --v) {
          fn7(k);
        }
        if (faces.length > 0 && directions[1]) {
          add_surface(vertices, scale_coeff, faces, materials[1], 1);
        }
        if (filter_internal && faces_internal.length > 0 && filter_directions[1]) {
          add_surface(vertices, scale_coeff, faces_internal, filter_materials[1], 4);
        }
      }
      if (dir !== 1) {
        if (j_index > 0) {
          j1 = j_lst_front[j_index - 1];
          j2 = j_lst_front[j_index];
          if (j_index >= j_lst_front.length / 2) {
            fn8 = function(i) {
              if (i_index < i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = w = 0, len4 = i_lst_front.length; w < len4; i_index = ++w) {
              i = i_lst_front[i_index];
              fn8(i);
            }
            results = [];
            for (i_index = y = 0, len5 = i_lst_back.length; y < len5; i_index = ++y) {
              i = i_lst_back[i_index];
              results.push((function(i) {
                if (i_index <= i_lst_front.length / 2) {
                  return i_part(0, i_index, k1, k2, j1, j2);
                }
              })(i));
            }
            return results;
          } else {
            fn9 = function(i) {
              if (i_index >= i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = z = 0, len6 = i_lst_front.length; z < len6; i_index = ++z) {
              i = i_lst_front[i_index];
              fn9(i);
            }
            results1 = [];
            for (i_index = aa = 0, len7 = i_lst_back.length; aa < len7; i_index = ++aa) {
              i = i_lst_back[i_index];
              results1.push((function(i) {
                if (i_index > i_lst_front.length / 2) {
                  return i_part(0, i_index, k1, k2, j1, j2);
                }
              })(i));
            }
            return results1;
          }
        }
      }
    };
    k_part = function(dir, k_index) {
      var faces, faces_internal, fn2, fn3, fn4, get_face_0, get_face_1, j, j_index, k, k1, k2, len, len1, p, q, ref, ref1, ref2, results, s, t, vertices;
      if (dir !== 0 && k_index > 0) {
        k1 = k_lst_front[k_index - 1];
        k2 = k_lst_front[k_index];
        if (k_index >= k_lst_front.length / 2) {
          fn2 = function(j) {
            j_part(0, j_lst_front.length - 1 - j_index, k1, k2);
            return j_part(1, j_index, k1, k2);
          };
          for (j_index = p = 0, len = j_lst_front.length; p < len; j_index = ++p) {
            j = j_lst_front[j_index];
            fn2(j);
          }
        }
      }
      k = k_lst_front[k_index];
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
      }
      if (j_first !== j_last && i_first !== i_last) {
        vertices = [];
        fn3 = function(j) {
          var ref2, ref3, results, s;
          results = [];
          for (i = s = ref2 = i_first, ref3 = i_last; ref2 <= ref3 ? s <= ref3 : s >= ref3; i = ref2 <= ref3 ? ++s : --s) {
            results.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results;
        };
        for (j = q = ref = j_first, ref1 = j_last; ref <= ref1 ? q <= ref1 : q >= ref1; j = ref <= ref1 ? ++q : --q) {
          fn3(j);
        }
        faces = [];
        faces_internal = [];
        fn4 = function(j) {
          var ref3, results, t;
          results = [];
          for (i = t = 0, ref3 = i_size - 1; 0 <= ref3 ? t <= ref3 : t >= ref3; i = 0 <= ref3 ? ++t : --t) {
            results.push((function(i) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && k >= filter[0][0] && k <= filter[0][1]) {
                if (internal_area(0, k, j, i)) {
                  if (indexOf.call(k_lst_filter, k) >= 0) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if (indexOf.call(k_lst_main, k) >= 0) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results;
        };
        for (j = s = 0, ref2 = j_size - 1; 0 <= ref2 ? s <= ref2 : s >= ref2; j = 0 <= ref2 ? ++s : --s) {
          fn4(j);
        }
        if (faces.length > 0 && directions[0]) {
          add_surface(vertices, scale_coeff, faces, materials[0], 0);
        }
        if (filter_internal && faces_internal.length > 0 && filter_directions[0]) {
          add_surface(vertices, scale_coeff, faces_internal, filter_materials[0], 3);
        }
      }
      if (dir !== 1 && k_index > 0) {
        k1 = k_lst_front[k_index - 1];
        k2 = k_lst_front[k_index];
        if (k_index < k_lst_front.length / 2) {
          results = [];
          for (j_index = t = 0, len1 = j_lst_front.length; t < len1; j_index = ++t) {
            j = j_lst_front[j_index];
            results.push((function(j) {
              j_part(0, j_lst_front.length - 1 - j_index, k1, k2);
              return j_part(1, j_index, k1, k2);
            })(j));
          }
          return results;
        }
      }
    };
    results = [];
    for (k_index = p = 0, len = k_lst_front.length; p < len; k_index = ++p) {
      k = k_lst_front[k_index];
      results.push((function(k) {
        k_part(1, k_index);
        return k_part(0, k_lst_front.length - 1 - k_index);
      })(k));
    }
    return results;
  };

  root.add_line = function(pnts, scale_coeff, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(pnts), 3));
    geometry.computeBoundingSphere();
    geometry.computeLineDistances();
    sceneObject = new THREE.Line(geometry, material);
    sceneObject.name = name;
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return root.lines.add(sceneObject);
  };

  root.add_surface = function(vertices, scale_coeff, faces, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.name = name;
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return root.faces.add(sceneObject);
  };

  root.GridLines = {
    init: function(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials) {
      var fn, fn1, get_segment, get_tail_segment, i, i_all, i_tmp, j_all, j_tmp, k_all, k_tmp, n, o;
      root.lines = new THREE.Object3D();
      root.k_last = data.length - 1;
      root.j_last = data[0].length - 1;
      root.i_last = data[0][0].length - 1;
      get_segment = function(l, r, step) {
        var fn, lst, n, ref, ref1, ref2, x;
        lst = [];
        fn = function(x) {
          return lst.push(x);
        };
        for (x = n = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? n <= ref1 : n >= ref1; x = n += ref2) {
          fn(x);
        }
        if (lst[lst.length - 1] !== r) {
          lst.push(r);
        }
        return lst;
      };
      get_tail_segment = function(l, r, step) {
        var fn, lst, n, ref, ref1, x;
        lst = [l];
        fn = function(x) {
          if (x > l) {
            return lst.push(x);
          }
        };
        for (x = n = 0, ref = r, ref1 = step; ref1 > 0 ? n <= ref : n >= ref; x = n += ref1) {
          fn(x);
        }
        if (lst[lst.length - 1] !== r) {
          lst.push(r);
        }
        return lst;
      };
      if (filter.length < 3) {
        k_all = get_segment(0, k_last, detail[0]);
        j_all = get_segment(0, j_last, detail[1]);
        i_all = get_segment(0, i_last, detail[2]);
        gen_lines(data, scale_coeff, [k_all, j_all, i_all], directions, materials);
      } else {
        fn = function(i) {
          var f;
          if (filter[i][0] < 0) {
            filter[i][0] = 0;
          }
          if (filter[i][1] < 0) {
            filter[i][1] = 0;
          }
          if (filter[i][2] < 1) {
            filter[i][2] = 1;
          }
          if (filter[i][0] > filter[i][1]) {
            f = filter[i][0];
            filter[i][0] = filter[i][1];
            return filter[i][1] = f;
          }
        };
        for (i = n = 0; n <= 2; i = ++n) {
          fn(i);
        }
        fn1 = function(i) {
          if (filter[0][i] > k_last) {
            filter[0][i] = k_last;
          }
          if (filter[1][i] > j_last) {
            filter[1][i] = j_last;
          }
          if (filter[2][i] > i_last) {
            return filter[2][i] = i_last;
          }
        };
        for (i = o = 0; o <= 2; i = ++o) {
          fn1(i);
        }
        j_all = get_segment(0, j_last, detail[1]);
        i_all = get_segment(0, i_last, detail[2]);
        k_tmp = get_segment(filter[0][0], filter[0][1], detail[0]);
        j_tmp = get_segment(filter[1][0], filter[1][1], detail[1]);
        if (filter[2][0] !== 0) {
          i_tmp = get_segment(0, filter[2][0], detail[2]);
          if (k_tmp.length && j_tmp.length && i_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_tmp], directions, materials);
          }
        }
        if (filter[2][1] !== i_last) {
          i_tmp = get_tail_segment(filter[2][1], i_last, detail[2]);
          if (k_tmp.length && j_tmp.length && i_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_tmp], directions, materials);
          }
        }
        if (filter[1][0] !== 0) {
          j_tmp = get_segment(0, filter[1][0], detail[1]);
          if (k_tmp.length && j_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_all], directions, materials);
          }
        }
        if (filter[1][1] !== j_last) {
          j_tmp = get_tail_segment(filter[1][1], j_last, detail[1]);
          if (k_tmp.length && j_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_all], directions, materials);
          }
        }
        if (filter[0][0] !== 0) {
          k_tmp = get_segment(0, filter[0][0], detail[0]);
          if (k_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_all, i_all], directions, materials);
          }
        }
        if (filter[0][1] !== k_last) {
          k_tmp = get_tail_segment(filter[0][1], k_last, detail[0]);
          if (k_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_all, i_all], directions, materials);
          }
        }
        k_tmp = get_segment(filter[0][0], filter[0][1], filter[0][2]);
        j_tmp = get_segment(filter[1][0], filter[1][1], filter[1][2]);
        i_tmp = get_segment(filter[2][0], filter[2][1], filter[2][2]);
        if (k_tmp.length && j_tmp.length && i_tmp.length) {
          gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_tmp], filter_directions, filter_materials, true);
        }
      }
      return root.lines;
    }
  };

  root.GridFaces = {
    init: function(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials) {
      var n1, n2, n3;
      root.faces = new THREE.Object3D();
      if (directions.length < 3) {
        directions = [false, false, false];
      }
      if (filter_directions.length < 3) {
        filter_directions = [true, true, true];
      }
      if (filter.length === 0) {
        gen_surfaces(data, scale_coeff, detail, directions, materials);
      } else if (filter.length > 2) {
        n1 = filter[0][0] !== filter[0][1] ? true : false;
        n2 = filter[1][0] !== filter[1][1] ? true : false;
        n3 = filter[2][0] !== filter[2][1] ? true : false;
        if ((n1 && n2) || (n1 && n3) || (n2 && n3)) {
          if (directions[0] || directions[1] || directions[2]) {
            gen_surfaces(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials);
          } else {
            gen_surfaces(data, scale_coeff, detail, filter_directions, filter_materials, filter);
          }
        }
      }
      return root.faces;
    }
  };

  root.GridPoints = {
    init: function(data, scale_coeff, variable, min, max, index, color, radius) {
      var colors, fn, fn1, geometry, i, k, len, material, n, o, paletter, positions, ref, v0, v1;
      geometry = new THREE.BufferGeometry();
      paletter = [];
      fn = function(i) {
        return paletter.push(parseInt(color[i].substring(1), 16));
      };
      for (i = n = 0, ref = color.length - 1; 0 <= ref ? n <= ref : n >= ref; i = 0 <= ref ? ++n : --n) {
        fn(i);
      }
      variable = parseInt(variable) + 2;
      v0 = min[variable];
      v1 = max[variable];
      positions = [];
      colors = [];
      fn1 = function(k) {
        var j, len1, p, results;
        results = [];
        for (p = 0, len1 = k.length; p < len1; p++) {
          j = k[p];
          results.push((function(j) {
            var len2, q, results1;
            results1 = [];
            for (q = 0, len2 = j.length; q < len2; q++) {
              i = j[q];
              results1.push((function(i) {
                var b, b0, b1, coeff, coeff_0, coeff_int, g, g0, g1, r, r0, r1, value;
                positions.push(i[0], i[1], i[2]);
                value = i[variable];
                coeff = (value - v0) / (v1 - v0);
                coeff_int = Math.floor(coeff * (paletter.length - 1));
                r0 = paletter[coeff_int] >> 16;
                g0 = (paletter[coeff_int] & 0x00ff00) >> 8;
                b0 = paletter[coeff_int] & 0x0000ff;
                if (coeff_int === paletter.length - 1) {
                  r = r0;
                  g = g0;
                  b = b0;
                } else {
                  r1 = paletter[coeff_int + 1] >> 16;
                  g1 = (paletter[coeff_int + 1] & 0x00ff00) >> 8;
                  b1 = paletter[coeff_int + 1] & 0x0000ff;
                  coeff_0 = coeff * (paletter.length - 1) - coeff_int;
                  r = (r1 - r0) * coeff_0 + r0;
                  g = (g1 - g0) * coeff_0 + g0;
                  b = (b1 - b0) * coeff_0 + b0;
                }
                return colors.push(r / 255, g / 255, b / 255);
              })(i));
            }
            return results1;
          })(j));
        }
        return results;
      };
      for (o = 0, len = data.length; o < len; o++) {
        k = data[o];
        fn1(k);
      }
      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
      material = new THREE.PointCloudMaterial({
        vertexColors: THREE.VertexColors,
        size: radius,
        sizeAttenuation: true
      });
      root.points = new THREE.PointCloud(geometry, material);
      root.points.scale.set(scale_coeff, scale_coeff, scale_coeff);
      root.points.sortParticles = true;
      return root.points;
    }
  };

}).call(this);
