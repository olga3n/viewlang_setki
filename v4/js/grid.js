// Generated by CoffeeScript 1.9.3
(function() {
  var root,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.gen_lines = function(data, scale_coeff, lst, style, filter) {
    var border_bold, borders, calc_color, color_border, fn, fn1, i_first, i_last, i_lst, i_seg, i_size, j, j_first, j_last, j_lst, j_seg, j_size, k, k_first, k_last, k_lst, k_seg, k_size, len, len1, len2, line_dashed, m, n, o, p, q, results, results1, results2, results3, s;
    if (filter == null) {
      filter = false;
    }
    k_lst = lst[0];
    j_lst = lst[1];
    i_lst = lst[2];
    k_first = k_lst[0];
    j_first = j_lst[0];
    i_first = i_lst[0];
    k_last = k_lst[k_lst.length - 1];
    j_last = j_lst[j_lst.length - 1];
    i_last = i_lst[i_lst.length - 1];
    k_seg = (function() {
      results = [];
      for (var m = k_first; k_first <= k_last ? m <= k_last : m >= k_last; k_first <= k_last ? m++ : m--){ results.push(m); }
      return results;
    }).apply(this);
    j_seg = (function() {
      results1 = [];
      for (var n = j_first; j_first <= j_last ? n <= j_last : n >= j_last; j_first <= j_last ? n++ : n--){ results1.push(n); }
      return results1;
    }).apply(this);
    i_seg = (function() {
      results2 = [];
      for (var o = i_first; i_first <= i_last ? o <= i_last : o >= i_last; i_first <= i_last ? o++ : o--){ results2.push(o); }
      return results2;
    }).apply(this);
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    if (filter === true) {
      borders = [[k_first, k_last], [j_first, j_last], [i_first, i_last]];
    } else {
      borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
    }
    if (style.length < 3) {
      style = [[], [], []];
    }
    if (style[0].length < 3) {
      style[0] = [true, true, true];
    }
    if (style[1].length < 3) {
      calc_color = function(dir, k, j, i) {
        var i_coeff, j_coeff, k_coeff, mid;
        mid = 0x88;
        if (filter === true) {
          mid = 0xff;
        }
        i_coeff = dir === 1 ? mid : (i - i_first) / i_size * 0xff;
        j_coeff = dir === 2 ? mid : (j - j_first) / j_size * 0xff;
        k_coeff = dir === 3 ? mid : (k - k_first) / k_size * 0xff;
        return (k_coeff << 16) + (j_coeff << 8) + i_coeff;
      };
    } else if (style[1].length > 2) {
      calc_color = function(dir, k, j, i) {
        return style[1][dir - 1];
      };
    }
    if (style.length > 2 && style[2].length > 0) {
      line_dashed = style[2][0];
    } else {
      line_dashed = false;
    }
    if (style.length > 2 && style[1].length > 3 && style[2].length > 1) {
      color_border = style[1][3];
      border_bold = style[2][1];
    } else {
      color_border = '#000000';
      if (filter === true) {
        color_border = '#0000ff';
      }
      border_bold = true;
    }
    if (style[0][0]) {
      fn = function(k) {
        var j, len1, q, results3;
        results3 = [];
        for (q = 0, len1 = j_lst.length; q < len1; q++) {
          j = j_lst[q];
          results3.push((function(j) {
            var color, dashed, fn1, i, len2, pnts, s, width;
            pnts = [];
            fn1 = function(i) {
              return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
            };
            for (s = 0, len2 = i_seg.length; s < len2; s++) {
              i = i_seg[s];
              fn1(i);
            }
            if (border_bold && indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[1], j) >= 0) {
              width = 2.5;
            } else {
              width = 1;
            }
            if (indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[1], j) >= 0) {
              color = color_border;
              dashed = false;
            } else {
              color = calc_color(1, k, j, 0);
              dashed = line_dashed;
            }
            return add_line(pnts, scale_coeff, color, dashed, width);
          })(j));
        }
        return results3;
      };
      for (p = 0, len = k_lst.length; p < len; p++) {
        k = k_lst[p];
        fn(k);
      }
    }
    if (style[0][1]) {
      fn1 = function(k) {
        var i, len2, results3, s;
        results3 = [];
        for (s = 0, len2 = i_lst.length; s < len2; s++) {
          i = i_lst[s];
          results3.push((function(i) {
            var color, dashed, fn2, j, len3, pnts, t, width;
            pnts = [];
            fn2 = function(j) {
              return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
            };
            for (t = 0, len3 = j_seg.length; t < len3; t++) {
              j = j_seg[t];
              fn2(j);
            }
            if (border_bold && indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[2], i) >= 0) {
              width = 2.5;
            } else {
              width = 1;
            }
            if (indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[2], i) >= 0) {
              color = color_border;
              dashed = false;
            } else {
              color = calc_color(2, k, 0, i);
              dashed = line_dashed;
            }
            return add_line(pnts, scale_coeff, color, dashed, width);
          })(i));
        }
        return results3;
      };
      for (q = 0, len1 = k_lst.length; q < len1; q++) {
        k = k_lst[q];
        fn1(k);
      }
    }
    if (style[0][2]) {
      results3 = [];
      for (s = 0, len2 = j_lst.length; s < len2; s++) {
        j = j_lst[s];
        results3.push((function(j) {
          var i, len3, results4, t;
          results4 = [];
          for (t = 0, len3 = i_lst.length; t < len3; t++) {
            i = i_lst[t];
            results4.push((function(i) {
              var color, dashed, fn2, len4, pnts, u, width;
              pnts = [];
              fn2 = function(k) {
                return pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
              };
              for (u = 0, len4 = k_seg.length; u < len4; u++) {
                k = k_seg[u];
                fn2(k);
              }
              if (border_bold && indexOf.call(borders[1], j) >= 0 && indexOf.call(borders[2], i) >= 0) {
                width = 2.5;
              } else {
                width = 1;
              }
              if (indexOf.call(borders[1], j) >= 0 || indexOf.call(borders[2], i) >= 0) {
                color = color_border;
                dashed = false;
              } else {
                color = calc_color(3, 0, j, i);
                dashed = line_dashed;
              }
              return add_line(pnts, scale_coeff, color, dashed, width);
            })(i));
          }
          return results4;
        })(j));
      }
      return results3;
    }
  };

  root.gen_surfaces = function(data, scale_coeff, detail, style, filter, filter_style) {
    var color, compare, filter_color, filter_internal, filter_opacity, fn, fn1, get_segment, i, i_first, i_last, i_lst_back, i_lst_filter, i_lst_front, i_lst_main, i_size, j_first, j_last, j_lst_back, j_lst_filter, j_lst_front, j_lst_main, j_size, k, k_first, k_index, k_last, k_lst_back, k_lst_filter, k_lst_front, k_lst_main, k_size, len, m, merge, n, o, opacity, results, vec;
    if (filter == null) {
      filter = [];
    }
    if (filter_style == null) {
      filter_style = [];
    }
    k_first = 0;
    j_first = 0;
    i_first = 0;
    k_last = data.length - 1;
    j_last = data[0].length - 1;
    i_last = data[0][0].length - 1;
    get_segment = function(l, r, step) {
      var fn, lst, m, ref, ref1, ref2, x;
      lst = [];
      fn = function(x) {
        return lst.push(x);
      };
      for (x = m = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? m <= ref1 : m >= ref1; x = m += ref2) {
        fn(x);
      }
      if (lst[lst.length - 1] !== r) {
        lst.push(r);
      }
      return lst;
    };
    if (filter.length > 2) {
      fn = function(i) {
        var f;
        if (filter[i][0] < 0) {
          filter[i][0] = 0;
        }
        if (filter[i][1] < 0) {
          filter[i][1] = 0;
        }
        if (filter[i][2] < 1) {
          filter[i][2] = 1;
        }
        if (filter[i][0] > filter[i][1]) {
          f = filter[i][0];
          filter[i][0] = filter[i][1];
          return filter[i][1] = f;
        }
      };
      for (i = m = 0; m <= 2; i = ++m) {
        fn(i);
      }
      fn1 = function(i) {
        if (filter[0][i] > k_last) {
          filter[0][i] = k_last;
        }
        if (filter[1][i] > j_last) {
          filter[1][i] = j_last;
        }
        if (filter[2][i] > i_last) {
          return filter[2][i] = i_last;
        }
      };
      for (i = n = 0; n <= 2; i = ++n) {
        fn1(i);
      }
    }
    if (filter_style.length > 2) {
      k_lst_main = get_segment(k_first, k_last, detail[0]);
      j_lst_main = get_segment(j_first, j_last, detail[1]);
      i_lst_main = get_segment(i_first, i_last, detail[2]);
      k_lst_filter = get_segment(filter[0][0], filter[0][1], filter[0][2]);
      j_lst_filter = get_segment(filter[1][0], filter[1][1], filter[1][2]);
      i_lst_filter = get_segment(filter[2][0], filter[2][1], filter[2][2]);
      merge = function(a, b) {
        return a.concat(b.filter(function(x) {
          return a.indexOf(x) < 0;
        }));
      };
      k_lst_front = merge(k_lst_main, k_lst_filter);
      j_lst_front = merge(j_lst_main, j_lst_filter);
      i_lst_front = merge(i_lst_main, i_lst_filter);
      compare = function(a, b) {
        return a - b;
      };
      k_lst_front.sort(compare);
      j_lst_front.sort(compare);
      i_lst_front.sort(compare);
      k_lst_back = k_lst_front.slice();
      j_lst_back = j_lst_front.slice();
      i_lst_back = i_lst_front.slice();
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
      filter_internal = true;
    } else {
      if (filter.length > 2) {
        k_first = filter[0][0];
        j_first = filter[1][0];
        i_first = filter[2][0];
        k_last = filter[0][1];
        j_last = filter[1][1];
        i_last = filter[2][1];
        detail = [filter[0][2], filter[1][2], filter[2][2]];
      }
      k_lst_front = get_segment(k_first, k_last, detail[0]);
      j_lst_front = get_segment(j_first, j_last, detail[1]);
      i_lst_front = get_segment(i_first, i_last, detail[2]);
      k_lst_back = get_segment(k_first, k_last, detail[0]);
      j_lst_back = get_segment(j_first, j_last, detail[1]);
      i_lst_back = get_segment(i_first, i_last, detail[2]);
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
    }
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    if (style.length > 2 && style[2].length > 0) {
      opacity = style[2][0];
    } else {
      opacity = 0.5;
    }
    if (style.length > 1 && style[1].length > 2) {
      color = style[1];
    } else {
      color = ['#00ffff', '#ff00ff', '#ffff00'];
    }
    if (filter_style.length > 2 && filter_style[2].length > 0) {
      filter_opacity = filter_style[2][0];
    } else {
      filter_opacity = 0.5;
    }
    if (filter_style.length > 1 && filter_style[1].length > 2) {
      filter_color = filter_style[1];
    } else {
      filter_color = ['#00ff88', '#8800ff', '#ff8800'];
    }
    vec = function(k, j, i) {
      return new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
    };
    results = [];
    for (k_index = o = 0, len = k_lst_back.length; o < len; k_index = ++o) {
      k = k_lst_back[k_index];
      results.push((function(k) {
        var faces, faces_internal, fn2, fn3, fn4, fn5, fn6, fn7, j, j_index, len1, len2, p, q, ref, ref1, ref2, ref3, ref4, ref5, s, t, u, v, vertices;
        vertices = [];
        fn2 = function(j) {
          var q, ref2, ref3, results1;
          results1 = [];
          for (i = q = ref2 = i_first, ref3 = i_last; ref2 <= ref3 ? q <= ref3 : q >= ref3; i = ref2 <= ref3 ? ++q : --q) {
            results1.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results1;
        };
        for (j = p = ref = j_first, ref1 = j_last; ref <= ref1 ? p <= ref1 : p >= ref1; j = ref <= ref1 ? ++p : --p) {
          fn2(j);
        }
        faces = [];
        faces_internal = [];
        fn3 = function(j) {
          var ref3, results1, s;
          results1 = [];
          for (i = s = 0, ref3 = i_size - 1; 0 <= ref3 ? s <= ref3 : s >= ref3; i = 0 <= ref3 ? ++s : --s) {
            results1.push((function(i) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = new THREE.Face3(b, a + 1, a);
              face_1 = new THREE.Face3(b + 1, a + 1, b);
              if (filter_internal) {
                if (indexOf.call(k_lst_filter, k) >= 0 && j >= filter[1][0] && j < filter[1][1] && i >= filter[2][0] && i < filter[2][1]) {
                  return faces_internal.push(face_0, face_1);
                } else if (indexOf.call(k_lst_main, k) >= 0) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results1;
        };
        for (j = q = 0, ref2 = j_size - 1; 0 <= ref2 ? q <= ref2 : q >= ref2; j = 0 <= ref2 ? ++q : --q) {
          fn3(j);
        }
        if (faces.length > 0 && style[0][0]) {
          add_surface(vertices, scale_coeff, faces, color[0], opacity);
        }
        if (filter_internal && faces_internal.length > 0 && filter_style[0][0]) {
          add_surface(vertices, scale_coeff, faces_internal, filter_color[0], filter_opacity);
        }
        if (k_index < k_lst_back.length - 1) {
          fn4 = function(j) {
            var fn5, fn6, i_index, k_index_size, len2, ref3, ref4, ref5, results1, t, u, v;
            vertices = [];
            fn5 = function(k) {
              var ref5, ref6, results1, u;
              results1 = [];
              for (i = u = ref5 = i_first, ref6 = i_last; ref5 <= ref6 ? u <= ref6 : u >= ref6; i = ref5 <= ref6 ? ++u : --u) {
                results1.push((function(i) {
                  return vertices.push(vec(k, j, i));
                })(i));
              }
              return results1;
            };
            for (k = t = ref3 = k_lst_back[k_index + 1], ref4 = k_lst_back[k_index]; ref3 <= ref4 ? t <= ref4 : t >= ref4; k = ref3 <= ref4 ? ++t : --t) {
              fn5(k);
            }
            k_index_size = k_lst_back[k_index] - k_lst_back[k_index + 1];
            faces = [];
            faces_internal = [];
            fn6 = function(k) {
              var ref6, results1, v;
              results1 = [];
              for (i = v = 0, ref6 = i_size - 1; 0 <= ref6 ? v <= ref6 : v >= ref6; i = 0 <= ref6 ? ++v : --v) {
                results1.push((function(i) {
                  var a, b, face_0, face_1, k0;
                  a = (i_size + 1) * k + i;
                  b = (i_size + 1) * (k + 1) + i;
                  face_0 = new THREE.Face3(a, a + 1, b);
                  face_1 = new THREE.Face3(b, a + 1, b + 1);
                  if (filter_internal) {
                    k0 = k + k_lst_back[k_index + 1];
                    if (indexOf.call(j_lst_filter, j) >= 0 && k0 >= filter[0][0] && k0 < filter[0][1] && i >= filter[2][0] && i < filter[2][1]) {
                      return faces_internal.push(face_0, face_1);
                    } else if (indexOf.call(j_lst_main, j) >= 0) {
                      return faces.push(face_0, face_1);
                    }
                  } else {
                    return faces.push(face_0, face_1);
                  }
                })(i));
              }
              return results1;
            };
            for (k = u = 0, ref5 = k_index_size - 1; 0 <= ref5 ? u <= ref5 : u >= ref5; k = 0 <= ref5 ? ++u : --u) {
              fn6(k);
            }
            if (faces.length > 0 && style[0][1]) {
              add_surface(vertices, scale_coeff, faces, color[1], opacity);
            }
            if (filter_internal && faces_internal.length > 0 && filter_style[0][1]) {
              add_surface(vertices, scale_coeff, faces_internal, filter_color[1], filter_opacity);
            }
            if (j_index < j_lst_back.length - 1) {
              results1 = [];
              for (i_index = v = 0, len2 = i_lst_back.length; v < len2; i_index = ++v) {
                i = i_lst_back[i_index];
                results1.push((function(i) {
                  var fn7, fn8, j_index_size, ref6, ref7, ref8, w, y;
                  vertices = [];
                  fn7 = function(k) {
                    var ref8, ref9, results2, y;
                    results2 = [];
                    for (j = y = ref8 = j_lst_back[j_index + 1], ref9 = j_lst_back[j_index]; ref8 <= ref9 ? y <= ref9 : y >= ref9; j = ref8 <= ref9 ? ++y : --y) {
                      results2.push((function(j) {
                        return vertices.push(vec(k, j, i));
                      })(j));
                    }
                    return results2;
                  };
                  for (k = w = ref6 = k_lst_back[k_index + 1], ref7 = k_lst_back[k_index]; ref6 <= ref7 ? w <= ref7 : w >= ref7; k = ref6 <= ref7 ? ++w : --w) {
                    fn7(k);
                  }
                  k_index_size = k_lst_back[k_index] - k_lst_back[k_index + 1];
                  j_index_size = j_lst_back[j_index] - j_lst_back[j_index + 1];
                  faces = [];
                  faces_internal = [];
                  fn8 = function(k) {
                    var ref9, results2, z;
                    results2 = [];
                    for (j = z = 0, ref9 = j_index_size - 1; 0 <= ref9 ? z <= ref9 : z >= ref9; j = 0 <= ref9 ? ++z : --z) {
                      results2.push((function(j) {
                        var a, b, face_0, face_1, j0, k0;
                        a = (j_index_size + 1) * k + j;
                        b = (j_index_size + 1) * (k + 1) + j;
                        face_0 = new THREE.Face3(b, a + 1, a);
                        face_1 = new THREE.Face3(b + 1, a + 1, b);
                        if (filter_internal) {
                          k0 = k + k_lst_back[k_index + 1];
                          j0 = j + j_lst_back[j_index + 1];
                          if (indexOf.call(i_lst_filter, i) >= 0 && k0 >= filter[0][0] && k0 < filter[0][1] && j0 >= filter[1][0] && j0 < filter[1][1]) {
                            return faces_internal.push(face_0, face_1);
                          } else if (indexOf.call(i_lst_main, i) >= 0) {
                            return faces.push(face_0, face_1);
                          }
                        } else {
                          return faces.push(face_0, face_1);
                        }
                      })(j));
                    }
                    return results2;
                  };
                  for (k = y = 0, ref8 = k_index_size - 1; 0 <= ref8 ? y <= ref8 : y >= ref8; k = 0 <= ref8 ? ++y : --y) {
                    fn8(k);
                  }
                  if (faces.length > 0 && style[0][2]) {
                    add_surface(vertices, scale_coeff, faces, color[2], opacity);
                  }
                  if (filter_internal && faces_internal.length > 0 && filter_style[0][2]) {
                    return add_surface(vertices, scale_coeff, faces_internal, filter_color[2], filter_opacity);
                  }
                })(i));
              }
              return results1;
            }
          };
          for (j_index = s = 0, len1 = j_lst_back.length; s < len1; j_index = ++s) {
            j = j_lst_back[j_index];
            fn4(j);
          }
        }
        k = k_lst_front[k_index];
        if (k_index > 0) {
          fn5 = function(j) {
            var fn6, fn7, fn8, i_index, k_index_size, len3, ref3, ref4, ref5, u, v, w;
            if (j_index > 0) {
              fn6 = function(i) {
                var fn7, fn8, j_index_size, k_index_size, ref3, ref4, ref5, v, w;
                vertices = [];
                fn7 = function(k) {
                  var ref5, ref6, results1, w;
                  results1 = [];
                  for (j = w = ref5 = j_lst_front[j_index - 1], ref6 = j_lst_front[j_index]; ref5 <= ref6 ? w <= ref6 : w >= ref6; j = ref5 <= ref6 ? ++w : --w) {
                    results1.push((function(j) {
                      return vertices.push(vec(k, j, i));
                    })(j));
                  }
                  return results1;
                };
                for (k = v = ref3 = k_lst_front[k_index - 1], ref4 = k_lst_front[k_index]; ref3 <= ref4 ? v <= ref4 : v >= ref4; k = ref3 <= ref4 ? ++v : --v) {
                  fn7(k);
                }
                k_index_size = k_lst_front[k_index] - k_lst_front[k_index - 1];
                j_index_size = j_lst_front[j_index] - j_lst_front[j_index - 1];
                faces = [];
                faces_internal = [];
                fn8 = function(k) {
                  var ref6, results1, y;
                  results1 = [];
                  for (j = y = 0, ref6 = j_index_size - 1; 0 <= ref6 ? y <= ref6 : y >= ref6; j = 0 <= ref6 ? ++y : --y) {
                    results1.push((function(j) {
                      var a, b, face_0, face_1, j0, k0;
                      a = (j_index_size + 1) * k + j;
                      b = (j_index_size + 1) * (k + 1) + j;
                      face_0 = new THREE.Face3(a, a + 1, b);
                      face_1 = new THREE.Face3(b, a + 1, b + 1);
                      if (filter_internal) {
                        k0 = k + k_lst_front[k_index - 1];
                        j0 = j + j_lst_front[j_index - 1];
                        if (indexOf.call(i_lst_filter, i) >= 0 && k0 >= filter[0][0] && k0 < filter[0][1] && j0 >= filter[1][0] && j0 < filter[1][1]) {
                          return faces_internal.push(face_0, face_1);
                        } else if (indexOf.call(i_lst_main, i) >= 0) {
                          return faces.push(face_0, face_1);
                        }
                      } else {
                        return faces.push(face_0, face_1);
                      }
                    })(j));
                  }
                  return results1;
                };
                for (k = w = 0, ref5 = k_index_size - 1; 0 <= ref5 ? w <= ref5 : w >= ref5; k = 0 <= ref5 ? ++w : --w) {
                  fn8(k);
                }
                if (faces.length > 0 && style[0][2]) {
                  add_surface(vertices, scale_coeff, faces, color[2], opacity);
                }
                if (filter_internal && faces_internal.length > 0 && filter_style[0][2]) {
                  return add_surface(vertices, scale_coeff, faces_internal, filter_color[2], filter_opacity);
                }
              };
              for (i_index = u = 0, len3 = i_lst_front.length; u < len3; i_index = ++u) {
                i = i_lst_front[i_index];
                fn6(i);
              }
            }
            j = j_lst_front[j_index];
            vertices = [];
            fn7 = function(k) {
              var ref5, ref6, results1, w;
              results1 = [];
              for (i = w = ref5 = i_first, ref6 = i_last; ref5 <= ref6 ? w <= ref6 : w >= ref6; i = ref5 <= ref6 ? ++w : --w) {
                results1.push((function(i) {
                  return vertices.push(vec(k, j, i));
                })(i));
              }
              return results1;
            };
            for (k = v = ref3 = k_lst_back[k_index], ref4 = k_lst_back[k_index - 1]; ref3 <= ref4 ? v <= ref4 : v >= ref4; k = ref3 <= ref4 ? ++v : --v) {
              fn7(k);
            }
            k_index_size = k_lst_back[k_index - 1] - k_lst_back[k_index];
            faces = [];
            faces_internal = [];
            fn8 = function(k) {
              var ref6, results1, y;
              results1 = [];
              for (i = y = 0, ref6 = i_size - 1; 0 <= ref6 ? y <= ref6 : y >= ref6; i = 0 <= ref6 ? ++y : --y) {
                results1.push((function(i) {
                  var a, b, face_0, face_1, k0;
                  a = (i_size + 1) * k + i;
                  b = (i_size + 1) * (k + 1) + i;
                  face_0 = new THREE.Face3(b, a + 1, a);
                  face_1 = new THREE.Face3(b + 1, a + 1, b);
                  if (filter_internal) {
                    k0 = k + k_lst_back[k_index];
                    if (indexOf.call(j_lst_filter, j) >= 0 && k0 >= filter[0][0] && k0 < filter[0][1] && i >= filter[2][0] && i < filter[2][1]) {
                      return faces_internal.push(face_0, face_1);
                    } else if (indexOf.call(j_lst_main, j) >= 0) {
                      return faces.push(face_0, face_1);
                    }
                  } else {
                    return faces.push(face_0, face_1);
                  }
                })(i));
              }
              return results1;
            };
            for (k = w = 0, ref5 = k_index_size - 1; 0 <= ref5 ? w <= ref5 : w >= ref5; k = 0 <= ref5 ? ++w : --w) {
              fn8(k);
            }
            if (faces.length > 0 && style[0][1]) {
              add_surface(vertices, scale_coeff, faces, color[1], opacity);
            }
            if (filter_internal && faces_internal.length > 0 && filter_style[0][1]) {
              return add_surface(vertices, scale_coeff, faces_internal, filter_color[1], filter_opacity);
            }
          };
          for (j_index = t = 0, len2 = j_lst_front.length; t < len2; j_index = ++t) {
            j = j_lst_front[j_index];
            fn5(j);
          }
        }
        k = k_lst_front[k_index];
        vertices = [];
        fn6 = function(j) {
          var ref5, ref6, results1, v;
          results1 = [];
          for (i = v = ref5 = i_first, ref6 = i_last; ref5 <= ref6 ? v <= ref6 : v >= ref6; i = ref5 <= ref6 ? ++v : --v) {
            results1.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results1;
        };
        for (j = u = ref3 = j_first, ref4 = j_last; ref3 <= ref4 ? u <= ref4 : u >= ref4; j = ref3 <= ref4 ? ++u : --u) {
          fn6(j);
        }
        faces = [];
        faces_internal = [];
        fn7 = function(j) {
          var ref6, results1, w;
          results1 = [];
          for (i = w = 0, ref6 = i_size - 1; 0 <= ref6 ? w <= ref6 : w >= ref6; i = 0 <= ref6 ? ++w : --w) {
            results1.push((function(i) {
              var a, b, face_0, face_1, ref7;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = new THREE.Face3(a, a + 1, b);
              face_1 = new THREE.Face3(b, a + 1, b + 1);
              if (filter_internal) {
                if ((ref7 = k_lst_front[k_index], indexOf.call(k_lst_filter, ref7) >= 0) && j >= filter[1][0] && j < filter[1][1] && i >= filter[2][0] && i < filter[2][1]) {
                  return faces_internal.push(face_0, face_1);
                } else if (indexOf.call(k_lst_main, k) >= 0) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results1;
        };
        for (j = v = 0, ref5 = j_size - 1; 0 <= ref5 ? v <= ref5 : v >= ref5; j = 0 <= ref5 ? ++v : --v) {
          fn7(j);
        }
        if (faces.length > 0 && style[0][0]) {
          add_surface(vertices, scale_coeff, faces, color[0], opacity);
        }
        if (filter_internal && faces_internal.length > 0 && filter_style[0][0]) {
          return add_surface(vertices, scale_coeff, faces_internal, filter_color[0], filter_opacity);
        }
      })(k));
    }
    return results;
  };

  root.add_line = function(pnts, scale_coeff, color, dashed, width) {
    var geometry, material, sceneObject;
    if (width == null) {
      width = 1;
    }
    geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(pnts), 3));
    geometry.computeBoundingSphere();
    if (dashed) {
      material = new THREE.LineDashedMaterial({
        color: color,
        linewidth: width,
        dashSize: 0.02,
        gapSize: 0.01
      });
      geometry.computeLineDistances();
    } else {
      material = new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      });
    }
    sceneObject = new THREE.Line(geometry, material);
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return root.lines.add(sceneObject);
  };

  root.add_surface = function(vertices, scale_coeff, faces, color, opacity) {
    var geometry, material, sceneObject;
    geometry = new THREE.Geometry();
    material = new THREE.MeshBasicMaterial({
      color: color,
      side: THREE.FrontSide,
      transparent: true,
      opacity: opacity
    });
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    return root.faces.add(sceneObject);
  };

  root.GridLines = {
    init: function(data, scale_coeff, detail, style, filter, filter_style) {
      var fn, fn1, get_segment, i, i_all, i_tmp, j_all, j_tmp, k_all, k_tmp, m, n;
      root.lines = new THREE.Object3D();
      if (style.length < 3) {
        style = [[], [], []];
      }
      root.k_last = data.length - 1;
      root.j_last = data[0].length - 1;
      root.i_last = data[0][0].length - 1;
      get_segment = function(l, r, step) {
        var fn, lst, m, ref, ref1, ref2, x;
        lst = [];
        fn = function(x) {
          return lst.push(x);
        };
        for (x = m = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? m <= ref1 : m >= ref1; x = m += ref2) {
          fn(x);
        }
        if (lst[lst.length - 1] !== r) {
          lst.push(r);
        }
        return lst;
      };
      if (filter.length < 3) {
        k_all = get_segment(0, k_last, detail[0]);
        j_all = get_segment(0, j_last, detail[1]);
        i_all = get_segment(0, i_last, detail[2]);
        gen_lines(data, scale_coeff, [k_all, j_all, i_all], style, filter, filter_style);
      } else {
        fn = function(i) {
          var f;
          if (filter[i][0] < 0) {
            filter[i][0] = 0;
          }
          if (filter[i][1] < 0) {
            filter[i][1] = 0;
          }
          if (filter[i][2] < 1) {
            filter[i][2] = 1;
          }
          if (filter[i][0] > filter[i][1]) {
            f = filter[i][0];
            filter[i][0] = filter[i][1];
            return filter[i][1] = f;
          }
        };
        for (i = m = 0; m <= 2; i = ++m) {
          fn(i);
        }
        fn1 = function(i) {
          if (filter[0][i] > k_last) {
            filter[0][i] = k_last;
          }
          if (filter[1][i] > j_last) {
            filter[1][i] = j_last;
          }
          if (filter[2][i] > i_last) {
            return filter[2][i] = i_last;
          }
        };
        for (i = n = 0; n <= 2; i = ++n) {
          fn1(i);
        }
        j_all = get_segment(0, j_last, detail[1]);
        i_all = get_segment(0, i_last, detail[2]);
        k_tmp = get_segment(filter[0][0], filter[0][1], filter[0][2]);
        j_tmp = get_segment(filter[1][0], filter[1][1], filter[1][2]);
        i_tmp = get_segment(filter[2][0], filter[2][1], filter[2][2]);
        if (filter[2][0] !== 0) {
          i_tmp = get_segment(0, filter[2][0], detail[2]);
          if (k_tmp.length && j_tmp.length && i_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_tmp], style);
          }
        }
        if (filter[2][1] !== i_last) {
          i_tmp = get_segment(filter[2][1], i_last, detail[2]);
          if (k_tmp.length && j_tmp.length && i_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_tmp], style);
          }
        }
        if (filter[1][0] !== 0) {
          j_tmp = get_segment(0, filter[1][0], detail[1]);
          if (k_tmp.length && j_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_all], style);
          }
        }
        if (filter[1][1] !== j_last) {
          j_tmp = get_segment(filter[1][1], j_last, detail[1]);
          if (k_tmp.length && j_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_all], style);
          }
        }
        if (filter[0][0] !== 0) {
          k_tmp = get_segment(0, filter[0][0], detail[0]);
          if (k_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_all, i_all], style);
          }
        }
        if (filter[0][1] !== k_last) {
          k_tmp = get_segment(filter[0][1], k_last, detail[0]);
          if (k_tmp.length) {
            gen_lines(data, scale_coeff, [k_tmp, j_all, i_all], style);
          }
        }
        k_tmp = get_segment(filter[0][0], filter[0][1], filter[0][2]);
        j_tmp = get_segment(filter[1][0], filter[1][1], filter[1][2]);
        i_tmp = get_segment(filter[2][0], filter[2][1], filter[2][2]);
        if (k_tmp.length && j_tmp.length && i_tmp.length) {
          gen_lines(data, scale_coeff, [k_tmp, j_tmp, i_tmp], filter_style, true);
        }
      }
      return root.lines;
    }
  };

  root.GridFaces = {
    init: function(data, scale_coeff, detail, style, filter, filter_style) {
      var n1, n2, n3;
      root.faces = new THREE.Object3D();
      if (style.length < 3) {
        style = [[], [], []];
      }
      if (filter_style.length < 3) {
        filter_style = [[], [], []];
      }
      if (style[0].length < 3) {
        style[0] = [false, false, false];
      }
      if (style[1].length < 3) {
        style[1] = ["#00ffff", "#ff00ff", "#ffff00"];
      }
      if (style[2].length < 1) {
        style[2] = [0.2];
      }
      if (filter_style[0].length < 3) {
        filter_style[0] = [true, true, true];
      }
      if (filter_style[1].length < 3) {
        filter_style[1] = ["#00ff88", "#8800ff", "#ff8800"];
      }
      if (filter_style[2].length < 1) {
        filter_style[2] = [0.2];
      }
      if (filter.length === 0) {
        gen_surfaces(data, scale_coeff, detail, style);
      } else if (filter.length > 2) {
        n1 = filter[0][0] !== filter[0][1] ? true : false;
        n2 = filter[1][0] !== filter[1][1] ? true : false;
        n3 = filter[2][0] !== filter[2][1] ? true : false;
        if ((n1 && n2) || (n1 && n3) || (n2 && n3)) {
          if (style[0][0] || style[0][1] || style[0][2]) {
            gen_surfaces(data, scale_coeff, detail, style, filter, filter_style);
          } else {
            gen_surfaces(data, scale_coeff, detail, filter_style, filter);
          }
        }
      }
      return root.faces;
    }
  };

}).call(this);
